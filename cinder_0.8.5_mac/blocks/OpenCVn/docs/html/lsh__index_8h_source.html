<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/opencv2/flann/lsh_index.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="lsh__index_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***********************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> * Software License Agreement (BSD License)</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright 2008-2009  Marius Muja (mariusm@cs.ubc.ca). All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright 2008-2009  David G. Lowe (lowe@cs.ubc.ca). All rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * THE BSD LICENSE</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00010"></a>00010 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00011"></a>00011 <span class="comment"> * are met:</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00014"></a>00014 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="l00015"></a>00015 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00016"></a>00016 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00017"></a>00017 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<a name="l00020"></a>00020 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<a name="l00021"></a>00021 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00022"></a>00022 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00023"></a>00023 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="l00024"></a>00024 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00028"></a>00028 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment"> *************************************************************************/</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment">/***********************************************************************</span>
<a name="l00032"></a>00032 <span class="comment"> * Author: Vincent Rabaud</span>
<a name="l00033"></a>00033 <span class="comment"> *************************************************************************/</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#ifndef OPENCV_FLANN_LSH_INDEX_H_</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define OPENCV_FLANN_LSH_INDEX_H_</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="general_8h.html">general.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="nn__index_8h.html">nn_index.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;matrix.h&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="result__set_8h.html">result_set.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="heap_8h.html">heap.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="lsh__table_8h.html">lsh_table.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="allocator_8h.html">allocator.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="random_8h.html">random.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="saving_8h.html">saving.h</a>&quot;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">namespace </span>cvflann
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056 
<a name="l00057"></a><a class="code" href="structcvflann_1_1_lsh_index_params.html">00057</a> <span class="keyword">struct </span><a class="code" href="structcvflann_1_1_lsh_index_params.html">LshIndexParams</a> : <span class="keyword">public</span> <a class="code" href="namespacecvflann.html#a742b4c7076c21012054af74a9ee48289">IndexParams</a>
<a name="l00058"></a>00058 {
<a name="l00059"></a><a class="code" href="structcvflann_1_1_lsh_index_params.html#aab336d3de5ee1a82c0c1c6e85c78a94c">00059</a>     <a class="code" href="structcvflann_1_1_lsh_index_params.html#aab336d3de5ee1a82c0c1c6e85c78a94c">LshIndexParams</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> table_number = 12, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_size = 20, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multi_probe_level = 2)
<a name="l00060"></a>00060     {
<a name="l00061"></a>00061         (* this)[<span class="stringliteral">&quot;algorithm&quot;</span>] = <a class="code" href="namespacecvflann.html#a4e3e6c98d774ea77fd7f0045c9bc7817a50d47941b69e28bd17f8ca1622420634">FLANN_INDEX_LSH</a>;
<a name="l00062"></a>00062         <span class="comment">// The number of hash tables to use</span>
<a name="l00063"></a>00063         (*this)[<span class="stringliteral">&quot;table_number&quot;</span>] = table_number;
<a name="l00064"></a>00064         <span class="comment">// The length of the key in the hash tables</span>
<a name="l00065"></a>00065         (*this)[<span class="stringliteral">&quot;key_size&quot;</span>] = key_size;
<a name="l00066"></a>00066         <span class="comment">// Number of levels to use in multi-probe (0 for standard LSH)</span>
<a name="l00067"></a>00067         (*this)[<span class="stringliteral">&quot;multi_probe_level&quot;</span>] = multi_probe_level;
<a name="l00068"></a>00068     }
<a name="l00069"></a>00069 };
<a name="l00070"></a>00070 
<a name="l00077"></a>00077 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Distance&gt;
<a name="l00078"></a><a class="code" href="classcvflann_1_1_lsh_index.html">00078</a> <span class="keyword">class </span><a class="code" href="classcvflann_1_1_lsh_index.html">LshIndex</a> : <span class="keyword">public</span> <a class="code" href="classcvflann_1_1_n_n_index.html">NNIndex</a>&lt;Distance&gt;
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080 <span class="keyword">public</span>:
<a name="l00081"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a2f042ae6416a2a78d1d9a7f622d1e284">00081</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Distance::ElementType <a class="code" href="classcvflann_1_1_lsh_index.html#a2f042ae6416a2a78d1d9a7f622d1e284">ElementType</a>;
<a name="l00082"></a><a class="code" href="classcvflann_1_1_lsh_index.html#aed0c5e217eff759f37ef2b91a9ddaae6">00082</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Distance::ResultType <a class="code" href="classcvflann_1_1_lsh_index.html#aed0c5e217eff759f37ef2b91a9ddaae6">DistanceType</a>;
<a name="l00083"></a>00083 
<a name="l00089"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a6ba735129e80fb9a229d5111f42300b4">00089</a>     <a class="code" href="classcvflann_1_1_lsh_index.html#a6ba735129e80fb9a229d5111f42300b4">LshIndex</a>(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;ElementType&gt;</a>&amp; input_data, <span class="keyword">const</span> <a class="code" href="namespacecvflann.html#a742b4c7076c21012054af74a9ee48289">IndexParams</a>&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a> = <a class="code" href="structcvflann_1_1_lsh_index_params.html">LshIndexParams</a>(),
<a name="l00090"></a>00090              Distance <a class="code" href="legacy_8hpp.html#a6f364afbe132c4ecfea48bde1b0618ba">d</a> = Distance()) :
<a name="l00091"></a>00091         dataset_(input_data), index_params_(<a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>), distance_(<a class="code" href="legacy_8hpp.html#a6f364afbe132c4ecfea48bde1b0618ba">d</a>)
<a name="l00092"></a>00092     {
<a name="l00093"></a>00093         <span class="comment">// cv::flann::IndexParams sets integer params as &#39;int&#39;, so it is used with get_param</span>
<a name="l00094"></a>00094         <span class="comment">// in place of &#39;unsigned int&#39;</span>
<a name="l00095"></a>00095         table_number_ = (<span class="keywordtype">unsigned</span> <a class="code" href="namespacecv_1_1gpu_1_1device.html#a75abe072f62e9cbacd4e282107467bbb">int</a>)get_param&lt;int&gt;(index_params_,<span class="stringliteral">&quot;table_number&quot;</span>,12);
<a name="l00096"></a>00096         key_size_ = (<span class="keywordtype">unsigned</span> <a class="code" href="namespacecv_1_1gpu_1_1device.html#a75abe072f62e9cbacd4e282107467bbb">int</a>)get_param&lt;int&gt;(index_params_,<span class="stringliteral">&quot;key_size&quot;</span>,20);
<a name="l00097"></a>00097         multi_probe_level_ = (<span class="keywordtype">unsigned</span> <a class="code" href="namespacecv_1_1gpu_1_1device.html#a75abe072f62e9cbacd4e282107467bbb">int</a>)get_param&lt;int&gt;(index_params_,<span class="stringliteral">&quot;multi_probe_level&quot;</span>,2);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         feature_size_ = (unsigned)dataset_.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>;
<a name="l00100"></a>00100         fill_xor_mask(0, key_size_, multi_probe_level_, xor_masks_);
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     <a class="code" href="classcvflann_1_1_lsh_index.html#a6ba735129e80fb9a229d5111f42300b4">LshIndex</a>(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_lsh_index.html">LshIndex</a>&amp;);
<a name="l00105"></a>00105     <a class="code" href="classcvflann_1_1_lsh_index.html">LshIndex</a>&amp; <a class="code" href="classcvflann_1_1_lsh_index.html#a93d4a58f0f102bd549002a4b2d224323">operator=</a>(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_lsh_index.html">LshIndex</a>&amp;);
<a name="l00106"></a>00106 
<a name="l00110"></a><a class="code" href="classcvflann_1_1_lsh_index.html#afc69f3b8bb0b70d6508f02afedefcd4f">00110</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_lsh_index.html#afc69f3b8bb0b70d6508f02afedefcd4f">buildIndex</a>()
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112         tables_.resize(table_number_);
<a name="l00113"></a>00113         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; table_number_; ++i) {
<a name="l00114"></a>00114             <a class="code" href="classcvflann_1_1lsh_1_1_lsh_table.html">lsh::LshTable&lt;ElementType&gt;</a>&amp; table = tables_[i];
<a name="l00115"></a>00115             table = <a class="code" href="classcvflann_1_1lsh_1_1_lsh_table.html">lsh::LshTable&lt;ElementType&gt;</a>(feature_size_, key_size_);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117             <span class="comment">// Add the features to the table</span>
<a name="l00118"></a>00118             table.<a class="code" href="classcvflann_1_1lsh_1_1_lsh_table.html#abcad1b9dca00f0d7b4f6751b8e2efcaf">add</a>(dataset_);
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 
<a name="l00122"></a><a class="code" href="classcvflann_1_1_lsh_index.html#afa13ae86bc473be70be44f5db63d1a06">00122</a>     <a class="code" href="namespacecvflann.html#a4e3e6c98d774ea77fd7f0045c9bc7817">flann_algorithm_t</a> <a class="code" href="classcvflann_1_1_lsh_index.html#afa13ae86bc473be70be44f5db63d1a06">getType</a>()<span class="keyword"> const</span>
<a name="l00123"></a>00123 <span class="keyword">    </span>{
<a name="l00124"></a>00124         <span class="keywordflow">return</span> <a class="code" href="namespacecvflann.html#a4e3e6c98d774ea77fd7f0045c9bc7817a50d47941b69e28bd17f8ca1622420634">FLANN_INDEX_LSH</a>;
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a2c4f2730a643239a5a633acd2534b95d">00128</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a2c4f2730a643239a5a633acd2534b95d" title="Saves the index to a stream.">saveIndex</a>(FILE* stream)
<a name="l00129"></a>00129     {
<a name="l00130"></a>00130         <a class="code" href="namespacecvflann.html#af21cc31d343e3e1132f34e11094d49a1">save_value</a>(stream,table_number_);
<a name="l00131"></a>00131         <a class="code" href="namespacecvflann.html#af21cc31d343e3e1132f34e11094d49a1">save_value</a>(stream,key_size_);
<a name="l00132"></a>00132         <a class="code" href="namespacecvflann.html#af21cc31d343e3e1132f34e11094d49a1">save_value</a>(stream,multi_probe_level_);
<a name="l00133"></a>00133         <a class="code" href="namespacecvflann.html#af21cc31d343e3e1132f34e11094d49a1">save_value</a>(stream, dataset_);
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135 
<a name="l00136"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a1dabad22feab89368be19fedf17b2511">00136</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a1dabad22feab89368be19fedf17b2511" title="Loads the index from a stream.">loadIndex</a>(FILE* stream)
<a name="l00137"></a>00137     {
<a name="l00138"></a>00138         <a class="code" href="namespacecvflann.html#ac76450e068ff8d95e2e5736141201faf">load_value</a>(stream, table_number_);
<a name="l00139"></a>00139         <a class="code" href="namespacecvflann.html#ac76450e068ff8d95e2e5736141201faf">load_value</a>(stream, key_size_);
<a name="l00140"></a>00140         <a class="code" href="namespacecvflann.html#ac76450e068ff8d95e2e5736141201faf">load_value</a>(stream, multi_probe_level_);
<a name="l00141"></a>00141         <a class="code" href="namespacecvflann.html#ac76450e068ff8d95e2e5736141201faf">load_value</a>(stream, dataset_);
<a name="l00142"></a>00142         <span class="comment">// Building the index is so fast we can afford not storing it</span>
<a name="l00143"></a>00143         <a class="code" href="classcvflann_1_1_lsh_index.html#afc69f3b8bb0b70d6508f02afedefcd4f">buildIndex</a>();
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         index_params_[<span class="stringliteral">&quot;algorithm&quot;</span>] = <a class="code" href="classcvflann_1_1_lsh_index.html#afa13ae86bc473be70be44f5db63d1a06">getType</a>();
<a name="l00146"></a>00146         index_params_[<span class="stringliteral">&quot;table_number&quot;</span>] = table_number_;
<a name="l00147"></a>00147         index_params_[<span class="stringliteral">&quot;key_size&quot;</span>] = key_size_;
<a name="l00148"></a>00148         index_params_[<span class="stringliteral">&quot;multi_probe_level&quot;</span>] = multi_probe_level_;
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150 
<a name="l00154"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a474fe6952d9ca8699c1c36b80ad15f05">00154</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a474fe6952d9ca8699c1c36b80ad15f05">size</a>()<span class="keyword"> const</span>
<a name="l00155"></a>00155 <span class="keyword">    </span>{
<a name="l00156"></a>00156         <span class="keywordflow">return</span> dataset_.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a>;
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158 
<a name="l00162"></a><a class="code" href="classcvflann_1_1_lsh_index.html#acdd5815793d1584b45615cdf075b3580">00162</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcvflann_1_1_lsh_index.html#acdd5815793d1584b45615cdf075b3580">veclen</a>()<span class="keyword"> const</span>
<a name="l00163"></a>00163 <span class="keyword">    </span>{
<a name="l00164"></a>00164         <span class="keywordflow">return</span> feature_size_;
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166 
<a name="l00171"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a30c7b5e70fceada2800db7357fa66259">00171</a>     <span class="keywordtype">int</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a30c7b5e70fceada2800db7357fa66259">usedMemory</a>()<span class="keyword"> const</span>
<a name="l00172"></a>00172 <span class="keyword">    </span>{
<a name="l00173"></a>00173         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(dataset_.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a> * <span class="keyword">sizeof</span>(<a class="code" href="namespacecv_1_1gpu_1_1device.html#a75abe072f62e9cbacd4e282107467bbb">int</a>));
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 
<a name="l00177"></a><a class="code" href="classcvflann_1_1_lsh_index.html#ae3eb8aa78a0b2e38baf0d89651b9b69a">00177</a>     <a class="code" href="namespacecvflann.html#a742b4c7076c21012054af74a9ee48289">IndexParams</a> <a class="code" href="classcvflann_1_1_lsh_index.html#ae3eb8aa78a0b2e38baf0d89651b9b69a">getParameters</a>()<span class="keyword"> const</span>
<a name="l00178"></a>00178 <span class="keyword">    </span>{
<a name="l00179"></a>00179         <span class="keywordflow">return</span> index_params_;
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00190"></a><a class="code" href="classcvflann_1_1_lsh_index.html#a82b5dd8af0ae2cbad219a42a66bcccbf">00190</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a82b5dd8af0ae2cbad219a42a66bcccbf" title="Perform k-nearest neighbor search.">knnSearch</a>(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;ElementType&gt;</a>&amp; queries, <a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;int&gt;</a>&amp; <a class="code" href="legacy_8hpp.html#a3e3b9b48bcbc7f460efbcfe4399ad24a">indices</a>, <a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;DistanceType&gt;</a>&amp; dists, <span class="keywordtype">int</span> knn, <span class="keyword">const</span> <a class="code" href="structcvflann_1_1_search_params.html">SearchParams</a>&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>)
<a name="l00191"></a>00191     {
<a name="l00192"></a>00192         assert(queries.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a> == <a class="code" href="classcvflann_1_1_lsh_index.html#acdd5815793d1584b45615cdf075b3580">veclen</a>());
<a name="l00193"></a>00193         assert(indices.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a> &gt;= queries.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a>);
<a name="l00194"></a>00194         assert(dists.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a> &gt;= queries.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a>);
<a name="l00195"></a>00195         assert(<span class="keywordtype">int</span>(indices.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>) &gt;= knn);
<a name="l00196"></a>00196         assert(<span class="keywordtype">int</span>(dists.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>) &gt;= knn);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         <a class="code" href="classcvflann_1_1_k_n_n_unique_result_set.html">KNNUniqueResultSet&lt;DistanceType&gt;</a> resultSet(knn);
<a name="l00200"></a>00200         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; queries.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a>; i++) {
<a name="l00201"></a>00201             resultSet.<a class="code" href="classcvflann_1_1_k_n_n_unique_result_set.html#afcf19c6a201b4580983b6baaae0a8383">clear</a>();
<a name="l00202"></a>00202             std::fill_n(indices[i], knn, -1);
<a name="l00203"></a>00203             std::fill_n(dists[i], knn, <a class="code" href="namespacecv.html#a22a8f8afb6090a66a771348b658dcebd" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::numeric_limits&lt;DistanceType&gt;::max</a>());
<a name="l00204"></a>00204             <a class="code" href="classcvflann_1_1_lsh_index.html#acde2974de8a4b2cfe72d849fdabddee9">findNeighbors</a>(resultSet, queries[i], params);
<a name="l00205"></a>00205             <span class="keywordflow">if</span> (<a class="code" href="namespacecvflann.html#a6ea20e8aad20212544cb42368c1e5b5f">get_param</a>(params,<span class="stringliteral">&quot;sorted&quot;</span>,<span class="keyword">true</span>)) resultSet.<a class="code" href="classcvflann_1_1_unique_result_set.html#afe9a25c34986cfa96a8e0032eab8c817">sortAndCopy</a>(indices[i], dists[i], knn);
<a name="l00206"></a>00206             <span class="keywordflow">else</span> resultSet.<a class="code" href="classcvflann_1_1_unique_result_set.html#a0d41e712bb5dff2dcf139f028df7d0f5">copy</a>(indices[i], dists[i], knn);
<a name="l00207"></a>00207         }
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 
<a name="l00220"></a><a class="code" href="classcvflann_1_1_lsh_index.html#acde2974de8a4b2cfe72d849fdabddee9">00220</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_lsh_index.html#acde2974de8a4b2cfe72d849fdabddee9">findNeighbors</a>(<a class="code" href="classcvflann_1_1_result_set.html">ResultSet&lt;DistanceType&gt;</a>&amp; <a class="code" href="core__c_8h.html#a14871c176a686a03035b5f2bbc72a63f">result</a>, <span class="keyword">const</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a2f042ae6416a2a78d1d9a7f622d1e284">ElementType</a>* vec, <span class="keyword">const</span> <a class="code" href="structcvflann_1_1_search_params.html">SearchParams</a>&amp; <span class="comment">/*searchParams*/</span>)
<a name="l00221"></a>00221     {
<a name="l00222"></a>00222         getNeighbors(vec, result);
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">private</span>:
<a name="l00228"></a>00228     <span class="keyword">typedef</span> std::pair&lt;float, unsigned int&gt; ScoreIndexPair;
<a name="l00229"></a>00229     <span class="keyword">struct </span>SortScoreIndexPairOnSecond
<a name="l00230"></a>00230     {
<a name="l00231"></a>00231         <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> ScoreIndexPair&amp; left, <span class="keyword">const</span> ScoreIndexPair&amp; <a class="code" href="calib3d_8hpp.html#a6b04b878081bf724144b73c75dfd1894">right</a>)<span class="keyword"> const</span>
<a name="l00232"></a>00232 <span class="keyword">        </span>{
<a name="l00233"></a>00233             <span class="keywordflow">return</span> left.second &lt; right.second;
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235     };
<a name="l00236"></a>00236 
<a name="l00243"></a>00243     <span class="keywordtype">void</span> fill_xor_mask(<a class="code" href="namespacecvflann_1_1lsh.html#a798313f0f282f24b311c4cc90e2a6619">lsh::BucketKey</a> <a class="code" href="core__c_8h.html#a68cf695b604d08c0b6f6f6bb282a6586">key</a>, <span class="keywordtype">int</span> lowest_index, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="legacy_8hpp.html#ac693e272fb1883fe0343f55a14d72b22">level</a>,
<a name="l00244"></a>00244                        std::vector&lt;lsh::BucketKey&gt;&amp; xor_masks)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246         xor_masks.push_back(key);
<a name="l00247"></a>00247         <span class="keywordflow">if</span> (level == 0) <span class="keywordflow">return</span>;
<a name="l00248"></a>00248         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a> = lowest_index - 1; <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a> &gt;= 0; --<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) {
<a name="l00249"></a>00249             <span class="comment">// Create a new key</span>
<a name="l00250"></a>00250             <a class="code" href="namespacecvflann_1_1lsh.html#a798313f0f282f24b311c4cc90e2a6619">lsh::BucketKey</a> new_key = key | (1 &lt;&lt; <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>);
<a name="l00251"></a>00251             fill_xor_mask(new_key, <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, level - 1, xor_masks);
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00263"></a>00263     <span class="keywordtype">void</span> getNeighbors(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a2f042ae6416a2a78d1d9a7f622d1e284">ElementType</a>* vec, <span class="keywordtype">bool</span> <span class="comment">/*do_radius*/</span>, <span class="keywordtype">float</span> <a class="code" href="core__c_8h.html#a7bea932e1cd0c79d103a7870a1921a4e">radius</a>, <span class="keywordtype">bool</span> do_k, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_nn,
<a name="l00264"></a>00264                       <span class="keywordtype">float</span>&amp; <span class="comment">/*checked_average*/</span>)
<a name="l00265"></a>00265     {
<a name="l00266"></a>00266         <span class="keyword">static</span> std::vector&lt;ScoreIndexPair&gt; score_index_heap;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         <span class="keywordflow">if</span> (do_k) {
<a name="l00269"></a>00269             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> worst_score = <a class="code" href="namespacecv.html#a22a8f8afb6090a66a771348b658dcebd" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::numeric_limits&lt;unsigned int&gt;::max</a>();
<a name="l00270"></a>00270             <span class="keyword">typename</span> std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt;::const_iterator table = tables_.begin();
<a name="l00271"></a>00271             <span class="keyword">typename</span> std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt;::const_iterator table_end = tables_.end();
<a name="l00272"></a>00272             <span class="keywordflow">for</span> (; table != table_end; ++table) {
<a name="l00273"></a>00273                 <span class="keywordtype">size_t</span> key = table-&gt;getKey(vec);
<a name="l00274"></a>00274                 std::vector&lt;lsh::BucketKey&gt;::const_iterator xor_mask = xor_masks_.begin();
<a name="l00275"></a>00275                 std::vector&lt;lsh::BucketKey&gt;::const_iterator xor_mask_end = xor_masks_.end();
<a name="l00276"></a>00276                 <span class="keywordflow">for</span> (; xor_mask != xor_mask_end; ++xor_mask) {
<a name="l00277"></a>00277                     <span class="keywordtype">size_t</span> sub_key = key ^ (*xor_mask);
<a name="l00278"></a>00278                     <span class="keyword">const</span> <a class="code" href="namespacecvflann_1_1lsh.html#aef9e4f70918d6013ff72020141fa03d0">lsh::Bucket</a>* bucket = table-&gt;getBucketFromKey(sub_key);
<a name="l00279"></a>00279                     <span class="keywordflow">if</span> (bucket == 0) <span class="keywordflow">continue</span>;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281                     <span class="comment">// Go over each descriptor index</span>
<a name="l00282"></a>00282                     std::vector&lt;lsh::FeatureIndex&gt;::const_iterator training_index = bucket-&gt;begin();
<a name="l00283"></a>00283                     std::vector&lt;lsh::FeatureIndex&gt;::const_iterator last_training_index = bucket-&gt;end();
<a name="l00284"></a>00284                     <a class="code" href="classcvflann_1_1_lsh_index.html#aed0c5e217eff759f37ef2b91a9ddaae6">DistanceType</a> hamming_distance;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286                     <span class="comment">// Process the rest of the candidates</span>
<a name="l00287"></a>00287                     <span class="keywordflow">for</span> (; training_index &lt; last_training_index; ++training_index) {
<a name="l00288"></a>00288                         hamming_distance = distance_(vec, dataset_[*training_index], dataset_.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290                         <span class="keywordflow">if</span> (hamming_distance &lt; worst_score) {
<a name="l00291"></a>00291                             <span class="comment">// Insert the new element</span>
<a name="l00292"></a>00292                             score_index_heap.push_back(ScoreIndexPair(hamming_distance, training_index));
<a name="l00293"></a>00293                             std::push_heap(score_index_heap.begin(), score_index_heap.end());
<a name="l00294"></a>00294 
<a name="l00295"></a>00295                             <span class="keywordflow">if</span> (score_index_heap.size() &gt; (<span class="keywordtype">unsigned</span> <a class="code" href="namespacecv_1_1gpu_1_1device.html#a75abe072f62e9cbacd4e282107467bbb">int</a>)k_nn) {
<a name="l00296"></a>00296                                 <span class="comment">// Remove the highest distance value as we have too many elements</span>
<a name="l00297"></a>00297                                 std::pop_heap(score_index_heap.begin(), score_index_heap.end());
<a name="l00298"></a>00298                                 score_index_heap.pop_back();
<a name="l00299"></a>00299                                 <span class="comment">// Keep track of the worst score</span>
<a name="l00300"></a>00300                                 worst_score = score_index_heap.front().first;
<a name="l00301"></a>00301                             }
<a name="l00302"></a>00302                         }
<a name="l00303"></a>00303                     }
<a name="l00304"></a>00304                 }
<a name="l00305"></a>00305             }
<a name="l00306"></a>00306         }
<a name="l00307"></a>00307         <span class="keywordflow">else</span> {
<a name="l00308"></a>00308             <span class="keyword">typename</span> std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt;::const_iterator table = tables_.begin();
<a name="l00309"></a>00309             <span class="keyword">typename</span> std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt;::const_iterator table_end = tables_.end();
<a name="l00310"></a>00310             <span class="keywordflow">for</span> (; table != table_end; ++table) {
<a name="l00311"></a>00311                 <span class="keywordtype">size_t</span> key = table-&gt;getKey(vec);
<a name="l00312"></a>00312                 std::vector&lt;lsh::BucketKey&gt;::const_iterator xor_mask = xor_masks_.begin();
<a name="l00313"></a>00313                 std::vector&lt;lsh::BucketKey&gt;::const_iterator xor_mask_end = xor_masks_.end();
<a name="l00314"></a>00314                 <span class="keywordflow">for</span> (; xor_mask != xor_mask_end; ++xor_mask) {
<a name="l00315"></a>00315                     <span class="keywordtype">size_t</span> sub_key = key ^ (*xor_mask);
<a name="l00316"></a>00316                     <span class="keyword">const</span> <a class="code" href="namespacecvflann_1_1lsh.html#aef9e4f70918d6013ff72020141fa03d0">lsh::Bucket</a>* bucket = table-&gt;getBucketFromKey(sub_key);
<a name="l00317"></a>00317                     <span class="keywordflow">if</span> (bucket == 0) <span class="keywordflow">continue</span>;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319                     <span class="comment">// Go over each descriptor index</span>
<a name="l00320"></a>00320                     std::vector&lt;lsh::FeatureIndex&gt;::const_iterator training_index = bucket-&gt;begin();
<a name="l00321"></a>00321                     std::vector&lt;lsh::FeatureIndex&gt;::const_iterator last_training_index = bucket-&gt;end();
<a name="l00322"></a>00322                     <a class="code" href="classcvflann_1_1_lsh_index.html#aed0c5e217eff759f37ef2b91a9ddaae6">DistanceType</a> hamming_distance;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324                     <span class="comment">// Process the rest of the candidates</span>
<a name="l00325"></a>00325                     <span class="keywordflow">for</span> (; training_index &lt; last_training_index; ++training_index) {
<a name="l00326"></a>00326                         <span class="comment">// Compute the Hamming distance</span>
<a name="l00327"></a>00327                         hamming_distance = distance_(vec, dataset_[*training_index], dataset_.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>);
<a name="l00328"></a>00328                         <span class="keywordflow">if</span> (hamming_distance &lt; radius) score_index_heap.push_back(ScoreIndexPair(hamming_distance, training_index));
<a name="l00329"></a>00329                     }
<a name="l00330"></a>00330                 }
<a name="l00331"></a>00331             }
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334 
<a name="l00339"></a>00339     <span class="keywordtype">void</span> getNeighbors(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_lsh_index.html#a2f042ae6416a2a78d1d9a7f622d1e284">ElementType</a>* vec, ResultSet&lt;DistanceType&gt;&amp; <a class="code" href="core__c_8h.html#a14871c176a686a03035b5f2bbc72a63f">result</a>)
<a name="l00340"></a>00340     {
<a name="l00341"></a>00341         <span class="keyword">typename</span> std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt;::const_iterator table = tables_.begin();
<a name="l00342"></a>00342         <span class="keyword">typename</span> std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt;::const_iterator table_end = tables_.end();
<a name="l00343"></a>00343         <span class="keywordflow">for</span> (; table != table_end; ++table) {
<a name="l00344"></a>00344             <span class="keywordtype">size_t</span> key = table-&gt;getKey(vec);
<a name="l00345"></a>00345             std::vector&lt;lsh::BucketKey&gt;::const_iterator xor_mask = xor_masks_.begin();
<a name="l00346"></a>00346             std::vector&lt;lsh::BucketKey&gt;::const_iterator xor_mask_end = xor_masks_.end();
<a name="l00347"></a>00347             <span class="keywordflow">for</span> (; xor_mask != xor_mask_end; ++xor_mask) {
<a name="l00348"></a>00348                 <span class="keywordtype">size_t</span> sub_key = key ^ (*xor_mask);
<a name="l00349"></a>00349                 <span class="keyword">const</span> <a class="code" href="namespacecvflann_1_1lsh.html#aef9e4f70918d6013ff72020141fa03d0">lsh::Bucket</a>* bucket = table-&gt;getBucketFromKey((<a class="code" href="namespacecvflann_1_1lsh.html#a798313f0f282f24b311c4cc90e2a6619">lsh::BucketKey</a>)sub_key);
<a name="l00350"></a>00350                 <span class="keywordflow">if</span> (bucket == 0) <span class="keywordflow">continue</span>;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352                 <span class="comment">// Go over each descriptor index</span>
<a name="l00353"></a>00353                 std::vector&lt;lsh::FeatureIndex&gt;::const_iterator training_index = bucket-&gt;begin();
<a name="l00354"></a>00354                 std::vector&lt;lsh::FeatureIndex&gt;::const_iterator last_training_index = bucket-&gt;end();
<a name="l00355"></a>00355                 <a class="code" href="classcvflann_1_1_lsh_index.html#aed0c5e217eff759f37ef2b91a9ddaae6">DistanceType</a> hamming_distance;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357                 <span class="comment">// Process the rest of the candidates</span>
<a name="l00358"></a>00358                 <span class="keywordflow">for</span> (; training_index &lt; last_training_index; ++training_index) {
<a name="l00359"></a>00359                     <span class="comment">// Compute the Hamming distance</span>
<a name="l00360"></a>00360                     hamming_distance = distance_(vec, dataset_[*training_index], (<span class="keywordtype">int</span>)dataset_.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>);
<a name="l00361"></a>00361                     result.addPoint(hamming_distance, *training_index);
<a name="l00362"></a>00362                 }
<a name="l00363"></a>00363             }
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366 
<a name="l00368"></a>00368     std::vector&lt;lsh::LshTable&lt;ElementType&gt; &gt; tables_;
<a name="l00369"></a>00369 
<a name="l00371"></a>00371     Matrix&lt;ElementType&gt; dataset_;
<a name="l00372"></a>00372 
<a name="l00374"></a>00374     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> feature_size_;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     <a class="code" href="namespacecvflann.html#a742b4c7076c21012054af74a9ee48289">IndexParams</a> index_params_;
<a name="l00377"></a>00377 
<a name="l00379"></a>00379     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> table_number_;
<a name="l00381"></a>00381     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_size_;
<a name="l00383"></a>00383     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> multi_probe_level_;
<a name="l00384"></a>00384 
<a name="l00386"></a>00386     std::vector&lt;lsh::BucketKey&gt; xor_masks_;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     Distance distance_;
<a name="l00389"></a>00389 };
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="preprocessor">#endif //OPENCV_FLANN_LSH_INDEX_H_</span>
</pre></div></div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
