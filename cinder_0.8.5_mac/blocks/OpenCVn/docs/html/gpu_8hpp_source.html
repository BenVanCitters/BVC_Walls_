<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/opencv2/gpu/gpu.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="gpu_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*M///////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//  By downloading, copying, installing or using the software you agree to this license.</span>
<a name="l00006"></a>00006 <span class="comment">//  If you do not agree to this license, do not download, install,</span>
<a name="l00007"></a>00007 <span class="comment">//  copy or use the software.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">//                           License Agreement</span>
<a name="l00011"></a>00011 <span class="comment">//                For Open Source Computer Vision Library</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.</span>
<a name="l00014"></a>00014 <span class="comment">// Copyright (C) 2009, Willow Garage Inc., all rights reserved.</span>
<a name="l00015"></a>00015 <span class="comment">// Third party copyrights are property of their respective owners.</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00017"></a>00017 <span class="comment">// Redistribution and use in source and binary forms, with or without modification,</span>
<a name="l00018"></a>00018 <span class="comment">// are permitted provided that the following conditions are met:</span>
<a name="l00019"></a>00019 <span class="comment">//</span>
<a name="l00020"></a>00020 <span class="comment">//   * Redistribution&#39;s of source code must retain the above copyright notice,</span>
<a name="l00021"></a>00021 <span class="comment">//     this list of conditions and the following disclaimer.</span>
<a name="l00022"></a>00022 <span class="comment">//</span>
<a name="l00023"></a>00023 <span class="comment">//   * Redistribution&#39;s in binary form must reproduce the above copyright notice,</span>
<a name="l00024"></a>00024 <span class="comment">//     this list of conditions and the following disclaimer in the documentation</span>
<a name="l00025"></a>00025 <span class="comment">//     and/or other GpuMaterials provided with the distribution.</span>
<a name="l00026"></a>00026 <span class="comment">//</span>
<a name="l00027"></a>00027 <span class="comment">//   * The name of the copyright holders may not be used to endorse or promote products</span>
<a name="l00028"></a>00028 <span class="comment">//     derived from this software without specific prior written permission.</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot; and</span>
<a name="l00031"></a>00031 <span class="comment">// any express or implied warranties, including, but not limited to, the implied</span>
<a name="l00032"></a>00032 <span class="comment">// warranties of merchantability and fitness for a particular purpose are disclaimed.</span>
<a name="l00033"></a>00033 <span class="comment">// In no event shall the Intel Corporation or contributors be liable for any direct,</span>
<a name="l00034"></a>00034 <span class="comment">// indirect, incidental, special, exemplary, or consequential damages</span>
<a name="l00035"></a>00035 <span class="comment">// (including, but not limited to, procurement of substitute goods or services;</span>
<a name="l00036"></a>00036 <span class="comment">// loss of use, data, or profits; or business interruption) however caused</span>
<a name="l00037"></a>00037 <span class="comment">// and on any theory of liability, whether in contract, strict liability,</span>
<a name="l00038"></a>00038 <span class="comment">// or tort (including negligence or otherwise) arising in any way out of</span>
<a name="l00039"></a>00039 <span class="comment">// the use of this software, even if advised of the possibility of such damage.</span>
<a name="l00040"></a>00040 <span class="comment">//</span>
<a name="l00041"></a>00041 <span class="comment">//M*/</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#ifndef __OPENCV_GPU_HPP__</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define __OPENCV_GPU_HPP__</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="preprocessor">#ifndef SKIP_INCLUDES</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;iosfwd&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="core_2gpumat_8hpp.html">opencv2/core/gpumat.hpp</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="imgproc_8hpp.html" title="The Image Processing.">opencv2/imgproc/imgproc.hpp</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="objdetect_8hpp.html">opencv2/objdetect/objdetect.hpp</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="features2d_2features2d_8hpp.html">opencv2/features2d/features2d.hpp</a>&quot;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">namespace </span>cv { <span class="keyword">namespace </span>gpu {
<a name="l00058"></a>00058 
<a name="l00060"></a>00060 <span class="comment">// CudaMem is limited cv::Mat with page locked memory allocation.</span>
<a name="l00061"></a>00061 <span class="comment">// Page locked memory is only needed for async and faster coping to GPU.</span>
<a name="l00062"></a>00062 <span class="comment">// It is convertable to cv::Mat header without reference counting</span>
<a name="l00063"></a>00063 <span class="comment">// so you can use it with other opencv functions.</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">// Page-locks the matrix m memory and maps it for the device(s)</span>
<a name="l00066"></a>00066 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a558eb0470ed87c78f8a0110b863c61a0">registerPageLocked</a>(Mat&amp; m);
<a name="l00067"></a>00067 <span class="comment">// Unmaps the memory of matrix m, and makes it pageable again.</span>
<a name="l00068"></a>00068 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa55a2e1497f0854b4a063f4a272055df">unregisterPageLocked</a>(Mat&amp; m);
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">00070</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>
<a name="l00071"></a>00071 {
<a name="l00072"></a>00072 <span class="keyword">public</span>:
<a name="l00073"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a6fef23a726177d71ca3e51855fd54531ad0e759094c5bec9f8e2712a77c04316c">00073</a>     <span class="keyword">enum</span>  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>();
<a name="l00076"></a>00076     <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>&amp; m);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>(<span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a061459acc9e078fa4699e0e349887215">rows</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a4407a60bc4387adae24cee658711f2d9">cols</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>, <span class="keywordtype">int</span> _alloc_type = ALLOC_PAGE_LOCKED);
<a name="l00079"></a>00079     <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>, <span class="keywordtype">int</span> alloc_type = ALLOC_PAGE_LOCKED);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 
<a name="l00083"></a>00083     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; m, <span class="keywordtype">int</span> alloc_type = ALLOC_PAGE_LOCKED);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     ~<a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>();
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>&amp; m);
<a name="l00088"></a>00088 
<a name="l00090"></a>00090     <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a> clone() <span class="keyword">const</span>;
<a name="l00091"></a>00091 
<a name="l00093"></a>00093     <span class="keywordtype">void</span> create(<span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a061459acc9e078fa4699e0e349887215">rows</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a4407a60bc4387adae24cee658711f2d9">cols</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>, <span class="keywordtype">int</span> alloc_type = ALLOC_PAGE_LOCKED);
<a name="l00094"></a>00094     <span class="keywordtype">void</span> create(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>, <span class="keywordtype">int</span> alloc_type = ALLOC_PAGE_LOCKED);
<a name="l00095"></a>00095 
<a name="l00097"></a>00097     <span class="keywordtype">void</span> release();
<a name="l00098"></a>00098 
<a name="l00100"></a>00100     <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> createMatHeader() <span class="keyword">const</span>;
<a name="l00101"></a>00101     operator Mat() <span class="keyword">const</span>;
<a name="l00102"></a>00102 
<a name="l00104"></a>00104     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> createGpuMatHeader() <span class="keyword">const</span>;
<a name="l00105"></a>00105     operator GpuMat() <span class="keyword">const</span>;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     <span class="comment">//returns if host memory can be mapperd to gpu address space;</span>
<a name="l00108"></a>00108     <span class="keyword">static</span> <span class="keywordtype">bool</span> canMapHostMemory();
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <span class="comment">// Please see cv::Mat for descriptions</span>
<a name="l00111"></a>00111     <span class="keywordtype">bool</span> isContinuous() <span class="keyword">const</span>;
<a name="l00112"></a>00112     <span class="keywordtype">size_t</span> elemSize() <span class="keyword">const</span>;
<a name="l00113"></a>00113     <span class="keywordtype">size_t</span> elemSize1() <span class="keyword">const</span>;
<a name="l00114"></a>00114     <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>() <span class="keyword">const</span>;
<a name="l00115"></a>00115     <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#acb5ba97551079e0b072c62c21d784ac5">depth</a>() <span class="keyword">const</span>;
<a name="l00116"></a>00116     <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a2876852c6a9947679c3003692de5aa83">channels</a>() <span class="keyword">const</span>;
<a name="l00117"></a>00117     <span class="keywordtype">size_t</span> step1() <span class="keyword">const</span>;
<a name="l00118"></a>00118     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>() <span class="keyword">const</span>;
<a name="l00119"></a>00119     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="comment">// Please see cv::Mat for descriptions</span>
<a name="l00123"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a312c10159c12ed29880b32bf32fedebc">00123</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a312c10159c12ed29880b32bf32fedebc">flags</a>;
<a name="l00124"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a7a9d3e9cac593f025c71e86a4e855f15">00124</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a7a9d3e9cac593f025c71e86a4e855f15">rows</a>, <a class="code" href="core__c_8h.html#a4407a60bc4387adae24cee658711f2d9">cols</a>;
<a name="l00125"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#aeac8b2b4d5cc098a8045902083df1ae2">00125</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#aeac8b2b4d5cc098a8045902083df1ae2">step</a>;
<a name="l00126"></a>00126 
<a name="l00127"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#aa354a703e72b23a67c266e53b7a55f26">00127</a>     <a class="code" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#aa354a703e72b23a67c266e53b7a55f26">data</a>;
<a name="l00128"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a6ade5baf301830405c01394c322087d2">00128</a>     <span class="keywordtype">int</span>* <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a6ade5baf301830405c01394c322087d2">refcount</a>;
<a name="l00129"></a>00129 
<a name="l00130"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a95693b049c55edf60c57733b80387ea9">00130</a>     <a class="code" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a95693b049c55edf60c57733b80387ea9">datastart</a>;
<a name="l00131"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a9daa5a5b4a9c028444f3b45bde90ad63">00131</a>     <a class="code" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a9daa5a5b4a9c028444f3b45bde90ad63">dataend</a>;
<a name="l00132"></a>00132 
<a name="l00133"></a><a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a253dcb37318ea0b109dca064678b88e0">00133</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html#a253dcb37318ea0b109dca064678b88e0">alloc_type</a>;
<a name="l00134"></a>00134 };
<a name="l00135"></a>00135 
<a name="l00137"></a>00137 <span class="comment">// Encapculates Cuda Stream. Provides interface for async coping.</span>
<a name="l00138"></a>00138 <span class="comment">// Passed to each function that supports async kernel execution.</span>
<a name="l00139"></a>00139 <span class="comment">// Reference counting is enabled</span>
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="classcv_1_1gpu_1_1_stream.html">00141</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>
<a name="l00142"></a>00142 {
<a name="l00143"></a>00143 <span class="keyword">public</span>:
<a name="l00144"></a>00144     <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>();
<a name="l00145"></a>00145     ~<a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>();
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp;);
<a name="l00148"></a>00148     <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp;);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keywordtype">bool</span> queryIfComplete();
<a name="l00151"></a>00151     <span class="keywordtype">void</span> waitForCompletion();
<a name="l00152"></a>00152 
<a name="l00154"></a>00154     <span class="comment">// Warning! cv::Mat must point to page locked memory (i.e. to CudaMem data or to its subMat)</span>
<a name="l00155"></a>00155     <span class="keywordtype">void</span> enqueueDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#af29de26095c2ca3a13726f87a7e4ff4e">src</a>, <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>&amp; <a class="code" href="namespacecv.html#a52bb929b38b35664f16102ee054f0b3d">dst</a>);
<a name="l00156"></a>00156     <span class="keywordtype">void</span> enqueueDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; dst);
<a name="l00157"></a>00157 
<a name="l00159"></a>00159     <span class="comment">// Warning! cv::Mat must point to page locked memory (i.e. to CudaMem data or to its ROI)</span>
<a name="l00160"></a>00160     <span class="keywordtype">void</span> enqueueUpload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_cuda_mem.html">CudaMem</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst);
<a name="l00161"></a>00161     <span class="keywordtype">void</span> enqueueUpload(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="keywordtype">void</span> enqueueCopy(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     <span class="keywordtype">void</span> enqueueMemSet(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> val);
<a name="l00166"></a>00166     <span class="keywordtype">void</span> enqueueMemSet(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> val, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="comment">// converts matrix type, ex from float to uchar depending on type</span>
<a name="l00169"></a>00169     <span class="keywordtype">void</span> enqueueConvert(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>, <span class="keywordtype">double</span> <a class="code" href="legacy_8hpp.html#a1031d0e0a97a340abfe0a6ab9e831045">a</a> = 1, <span class="keywordtype">double</span> <a class="code" href="legacy_8hpp.html#ac04272e8ca865b8fba18d36edae9fd2a">b</a> = 0);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="keyword">static</span> <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; Null();
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     operator bool() <span class="keyword">const</span>;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="keyword">private</span>:
<a name="l00176"></a>00176     <span class="keywordtype">void</span> create();
<a name="l00177"></a>00177     <span class="keywordtype">void</span> release();
<a name="l00178"></a>00178 
<a name="l00179"></a>00179     <span class="keyword">struct </span>Impl;
<a name="l00180"></a>00180     Impl *impl;
<a name="l00181"></a>00181 
<a name="l00182"></a><a class="code" href="classcv_1_1gpu_1_1_stream.html#a8362b5c9fdffe61e694647684353b090">00182</a>     <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="structcv_1_1gpu_1_1_stream_accessor.html">StreamAccessor</a>;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>(Impl* impl);
<a name="l00185"></a>00185 };
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00189"></a>00189 
<a name="l00196"></a><a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html">00196</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html" title="The Base Class for 1D or Row-wise Filters.">BaseRowFilter_GPU</a>
<a name="l00197"></a>00197 {
<a name="l00198"></a>00198 <span class="keyword">public</span>:
<a name="l00199"></a><a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html#a7121438e5db45a777d0453fd25d96ead">00199</a>     <a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html#a7121438e5db45a777d0453fd25d96ead">BaseRowFilter_GPU</a>(<span class="keywordtype">int</span> ksize_, <span class="keywordtype">int</span> anchor_) : ksize(ksize_), anchor(anchor_) {}
<a name="l00200"></a><a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html#af3f6539f6fccc43c07920bc9dacbd00a">00200</a>     <span class="keyword">virtual</span> <a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html#af3f6539f6fccc43c07920bc9dacbd00a">~BaseRowFilter_GPU</a>() {}
<a name="l00201"></a>00201     <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#af29de26095c2ca3a13726f87a7e4ff4e">src</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="namespacecv.html#a52bb929b38b35664f16102ee054f0b3d">dst</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) = 0;
<a name="l00202"></a><a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html#a913539544c388aa5194776cf1b918b91">00202</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_base_row_filter___g_p_u.html#a913539544c388aa5194776cf1b918b91">ksize</a>, anchor;
<a name="l00203"></a>00203 };
<a name="l00204"></a>00204 
<a name="l00211"></a><a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html">00211</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html" title="The Base Class for Column-wise Filters.">BaseColumnFilter_GPU</a>
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213 <span class="keyword">public</span>:
<a name="l00214"></a><a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html#a1f79fa59defd9ea1c2042ee1639ae697">00214</a>     <a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html#a1f79fa59defd9ea1c2042ee1639ae697">BaseColumnFilter_GPU</a>(<span class="keywordtype">int</span> ksize_, <span class="keywordtype">int</span> anchor_) : ksize(ksize_), anchor(anchor_) {}
<a name="l00215"></a><a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html#ada24bda7d86e139fa346ad9d34967945">00215</a>     <span class="keyword">virtual</span> <a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html#ada24bda7d86e139fa346ad9d34967945">~BaseColumnFilter_GPU</a>() {}
<a name="l00216"></a>00216     <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#af29de26095c2ca3a13726f87a7e4ff4e">src</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="namespacecv.html#a52bb929b38b35664f16102ee054f0b3d">dst</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) = 0;
<a name="l00217"></a><a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html#afb442622e8a2562273d75a6caf3abc10">00217</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_base_column_filter___g_p_u.html#afb442622e8a2562273d75a6caf3abc10">ksize</a>, anchor;
<a name="l00218"></a>00218 };
<a name="l00219"></a>00219 
<a name="l00225"></a><a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html">00225</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html" title="The Base Class for Non-Separable 2D Filters.">BaseFilter_GPU</a>
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227 <span class="keyword">public</span>:
<a name="l00228"></a><a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#ab76fd1d04c68a7a324e2b54e03bc09b2">00228</a>     <a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#ab76fd1d04c68a7a324e2b54e03bc09b2">BaseFilter_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; ksize_, <span class="keyword">const</span> <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>&amp; anchor_) : ksize(ksize_), anchor(anchor_) {}
<a name="l00229"></a><a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#a5e7ec9531cf580290af49d4cadebc6e0">00229</a>     <span class="keyword">virtual</span> <a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#a5e7ec9531cf580290af49d4cadebc6e0">~BaseFilter_GPU</a>() {}
<a name="l00230"></a>00230     <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#af29de26095c2ca3a13726f87a7e4ff4e">src</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="namespacecv.html#a52bb929b38b35664f16102ee054f0b3d">dst</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) = 0;
<a name="l00231"></a><a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#aa5e0771ce60a854ba7b98efc64655a62">00231</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#aa5e0771ce60a854ba7b98efc64655a62">ksize</a>;
<a name="l00232"></a><a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#abc14dff732da4164665c676366a210b3">00232</a>     <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> <a class="code" href="classcv_1_1gpu_1_1_base_filter___g_p_u.html#abc14dff732da4164665c676366a210b3">anchor</a>;
<a name="l00233"></a>00233 };
<a name="l00234"></a>00234 
<a name="l00241"></a><a class="code" href="classcv_1_1gpu_1_1_filter_engine___g_p_u.html">00241</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_filter_engine___g_p_u.html" title="The Base Class for Filter Engine.">FilterEngine_GPU</a>
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243 <span class="keyword">public</span>:
<a name="l00244"></a><a class="code" href="classcv_1_1gpu_1_1_filter_engine___g_p_u.html#a9f94a16322a4a2113fb18765c3e5a34c">00244</a>     <span class="keyword">virtual</span> <a class="code" href="classcv_1_1gpu_1_1_filter_engine___g_p_u.html#a9f94a16322a4a2113fb18765c3e5a34c">~FilterEngine_GPU</a>() {}
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#af29de26095c2ca3a13726f87a7e4ff4e">src</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="namespacecv.html#a52bb929b38b35664f16102ee054f0b3d">dst</a>, <a class="code" href="classcv_1_1_rect__.html">Rect</a> <a class="code" href="legacy_8hpp.html#a22e52b2b51d064865d3ac2f27b308c33">roi</a> = <a class="code" href="namespacecv.html#a954f5c2ab7c3f0f5d4eed444cdabf038">Rect</a>(0,0,-1,-1), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) = 0;
<a name="l00247"></a>00247 };
<a name="l00248"></a>00248 
<a name="l00250"></a>00250 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a69ab6da5fc06f6d80ce577ac5222837e" title="returns the non-separable filter engine with the specified filter">createFilter2D_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseFilter_GPU&gt;</a>&amp; <a class="code" href="namespacecv_1_1gpu.html#ad0dd9de5d0cfcd09316f6377d356e689" title="applies non-separable 2D linear filter to the image">filter2D</a>, <span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType);
<a name="l00251"></a>00251 
<a name="l00253"></a>00253 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a8fadfdcb3978e4d00e160cda4ad8dd01" title="returns the separable filter engine with the specified filters">createSeparableFilter_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseRowFilter_GPU&gt;</a>&amp; rowFilter,
<a name="l00254"></a>00254     <span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseColumnFilter_GPU&gt;</a>&amp; columnFilter, <span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> bufType, <span class="keywordtype">int</span> dstType);
<a name="l00255"></a>00255 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a8fadfdcb3978e4d00e160cda4ad8dd01" title="returns the separable filter engine with the specified filters">createSeparableFilter_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseRowFilter_GPU&gt;</a>&amp; rowFilter,
<a name="l00256"></a>00256     <span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseColumnFilter_GPU&gt;</a>&amp; columnFilter, <span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> bufType, <span class="keywordtype">int</span> dstType, GpuMat&amp; buf);
<a name="l00257"></a>00257 
<a name="l00260"></a>00260 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseRowFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a08c25ca8ae392ce3c147ba7bde8be68a">getRowSumFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> sumType, <span class="keywordtype">int</span> ksize, <span class="keywordtype">int</span> anchor = -1);
<a name="l00261"></a>00261 
<a name="l00264"></a>00264 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseColumnFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a8df9b23ff4b68ff6657d30ec58babbdb">getColumnSumFilter_GPU</a>(<span class="keywordtype">int</span> sumType, <span class="keywordtype">int</span> dstType, <span class="keywordtype">int</span> ksize, <span class="keywordtype">int</span> anchor = -1);
<a name="l00265"></a>00265 
<a name="l00268"></a>00268 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a5dd82b8d8e9ff9dc81f109235651e16c">getBoxFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; ksize, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1));
<a name="l00269"></a>00269 
<a name="l00271"></a>00271 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a581d4a246334ad155cdb05b72d004365" title="returns box filter engine">createBoxFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; ksize,
<a name="l00272"></a>00272     <span class="keyword">const</span> <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>&amp; anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1));
<a name="l00273"></a>00273 
<a name="l00278"></a>00278 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a61eac858fc4db7e2bb7adc16339e75a6">getMorphologyFilter_GPU</a>(<span class="keywordtype">int</span> op, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">type</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; <a class="code" href="imgproc__c_8h.html#a863a75780ba6c5de552f5361cb0d2c89">kernel</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; ksize,
<a name="l00279"></a>00279     <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor=<a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1));
<a name="l00280"></a>00280 
<a name="l00282"></a>00282 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#ae88103a59ce45048d8da0a7957225030" title="returns morphological filter engine. Only MORPH_ERODE and MORPH_DILATE are supported.">createMorphologyFilter_GPU</a>(<span class="keywordtype">int</span> op, <span class="keywordtype">int</span> type, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; kernel,
<a name="l00283"></a>00283     <span class="keyword">const</span> <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>&amp; anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1);
<a name="l00284"></a>00284 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#ae88103a59ce45048d8da0a7957225030" title="returns morphological filter engine. Only MORPH_ERODE and MORPH_DILATE are supported.">createMorphologyFilter_GPU</a>(<span class="keywordtype">int</span> op, <span class="keywordtype">int</span> type, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; kernel, GpuMat&amp; buf,
<a name="l00285"></a>00285     <span class="keyword">const</span> <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>&amp; anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1);
<a name="l00286"></a>00286 
<a name="l00289"></a>00289 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a8b6d0e95f7e2f3482b576b9244fa2c73">getLinearFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; kernel, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>);
<a name="l00290"></a>00290 
<a name="l00292"></a>00292 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a4eff0a876c702c05c80d12cde3ab9734" title="returns the non-separable linear filter engine">createLinearFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; kernel,
<a name="l00293"></a>00293     <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>);
<a name="l00294"></a>00294 
<a name="l00303"></a>00303 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseRowFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a09d017c88f5907fb446c1dd4a976a850">getLinearRowFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> bufType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; rowKernel,
<a name="l00304"></a>00304     <span class="keywordtype">int</span> anchor = -1, <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>);
<a name="l00305"></a>00305 
<a name="l00314"></a>00314 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseColumnFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a1710eb2f2056726f435ac86e15d8655a">getLinearColumnFilter_GPU</a>(<span class="keywordtype">int</span> bufType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; columnKernel,
<a name="l00315"></a>00315     <span class="keywordtype">int</span> anchor = -1, <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>);
<a name="l00316"></a>00316 
<a name="l00318"></a>00318 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#aa15197c6ae8c4c0afb4d6381615e18a8" title="returns the separable linear filter engine">createSeparableLinearFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; rowKernel,
<a name="l00319"></a>00319     <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; columnKernel, <span class="keyword">const</span> <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>&amp; anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>,
<a name="l00320"></a>00320     <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00321"></a>00321 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#aa15197c6ae8c4c0afb4d6381615e18a8" title="returns the separable linear filter engine">createSeparableLinearFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; rowKernel,
<a name="l00322"></a>00322     <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; columnKernel, GpuMat&amp; buf, <span class="keyword">const</span> <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>&amp; anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>,
<a name="l00323"></a>00323     <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00324"></a>00324 
<a name="l00326"></a>00326 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a22f92d67f1101beca408af27ad656f06" title="returns filter engine for the generalized Sobel operator">createDerivFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, <span class="keywordtype">int</span> ksize,
<a name="l00327"></a>00327                                                        <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00328"></a>00328 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a22f92d67f1101beca408af27ad656f06" title="returns filter engine for the generalized Sobel operator">createDerivFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, <span class="keywordtype">int</span> ksize, GpuMat&amp; buf,
<a name="l00329"></a>00329                                                        <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00330"></a>00330 
<a name="l00332"></a>00332 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#ad68c426ac3a0d3528f3f082432fda476" title="returns the Gaussian filter engine">createGaussianFilter_GPU</a>(<span class="keywordtype">int</span> type, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> ksize, <span class="keywordtype">double</span> sigma1, <span class="keywordtype">double</span> sigma2 = 0,
<a name="l00333"></a>00333                                                           <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00334"></a>00334 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#ad68c426ac3a0d3528f3f082432fda476" title="returns the Gaussian filter engine">createGaussianFilter_GPU</a>(<span class="keywordtype">int</span> type, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> ksize, GpuMat&amp; buf, <span class="keywordtype">double</span> sigma1, <span class="keywordtype">double</span> sigma2 = 0,
<a name="l00335"></a>00335                                                           <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00336"></a>00336 
<a name="l00338"></a>00338 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#ac63d2004163889ce9ee542aa6825e40d" title="returns maximum filter">getMaxFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; ksize, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1));
<a name="l00339"></a>00339 
<a name="l00341"></a>00341 CV_EXPORTS <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;BaseFilter_GPU&gt;</a> <a class="code" href="namespacecv_1_1gpu.html#a32a75aa2b5efdab8e932988950b76cdd" title="returns minimum filter">getMinFilter_GPU</a>(<span class="keywordtype">int</span> srcType, <span class="keywordtype">int</span> dstType, <span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; ksize, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1));
<a name="l00342"></a>00342 
<a name="l00345"></a>00345 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acfa94fd01be8c3b6a9468f5890ed79c7">boxFilter</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> ksize, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00346"></a>00346 
<a name="l00348"></a>00348 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> blur(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> ksize, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>())
<a name="l00349"></a>00349 {
<a name="l00350"></a>00350     <a class="code" href="namespacecv_1_1gpu.html#acfa94fd01be8c3b6a9468f5890ed79c7">boxFilter</a>(src, dst, -1, ksize, anchor, stream);
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00354"></a>00354 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acde1fa907eb49b82268dddaad211cf48" title="erodes the image (applies the local minimum operator)">erode</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> Mat&amp; kernel, <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1);
<a name="l00355"></a>00355 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acde1fa907eb49b82268dddaad211cf48" title="erodes the image (applies the local minimum operator)">erode</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> Mat&amp; kernel, GpuMat&amp; buf,
<a name="l00356"></a>00356                       <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1,
<a name="l00357"></a>00357                       Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00358"></a>00358 
<a name="l00360"></a>00360 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab96dbbbb7c539e8dda64de5a8ad76517" title="dilates the image (applies the local maximum operator)">dilate</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> Mat&amp; kernel, <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1);
<a name="l00361"></a>00361 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab96dbbbb7c539e8dda64de5a8ad76517" title="dilates the image (applies the local maximum operator)">dilate</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> Mat&amp; kernel, GpuMat&amp; buf,
<a name="l00362"></a>00362                        <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1,
<a name="l00363"></a>00363                        Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00364"></a>00364 
<a name="l00366"></a>00366 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0e97dc3a449eb0d70b9f832b06e0a0b4" title="applies an advanced morphological operation to the image">morphologyEx</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> op, <span class="keyword">const</span> Mat&amp; kernel, <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1);
<a name="l00367"></a>00367 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0e97dc3a449eb0d70b9f832b06e0a0b4" title="applies an advanced morphological operation to the image">morphologyEx</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> op, <span class="keyword">const</span> Mat&amp; kernel, GpuMat&amp; buf1, GpuMat&amp; buf2,
<a name="l00368"></a>00368                              <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1), <span class="keywordtype">int</span> <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a> = 1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00369"></a>00369 
<a name="l00371"></a>00371 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad0dd9de5d0cfcd09316f6377d356e689" title="applies non-separable 2D linear filter to the image">filter2D</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keyword">const</span> Mat&amp; kernel, <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor=<a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00372"></a>00372 
<a name="l00374"></a>00374 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a9bd6b91f2fe1800492af254100261fd1" title="applies separable 2D linear filter to the image">sepFilter2D</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keyword">const</span> Mat&amp; kernelX, <span class="keyword">const</span> Mat&amp; kernelY,
<a name="l00375"></a>00375                             <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00376"></a>00376 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a9bd6b91f2fe1800492af254100261fd1" title="applies separable 2D linear filter to the image">sepFilter2D</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keyword">const</span> Mat&amp; kernelX, <span class="keyword">const</span> Mat&amp; kernelY, GpuMat&amp; buf,
<a name="l00377"></a>00377                             <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> anchor = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1,-1), <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1,
<a name="l00378"></a>00378                             Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00379"></a>00379 
<a name="l00381"></a>00381 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aaef20414ce6d2e811ef9848e8991eb6c" title="applies generalized Sobel operator to the image">Sobel</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, <span class="keywordtype">int</span> ksize = 3, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1,
<a name="l00382"></a>00382                       <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00383"></a>00383 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aaef20414ce6d2e811ef9848e8991eb6c" title="applies generalized Sobel operator to the image">Sobel</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, GpuMat&amp; buf, <span class="keywordtype">int</span> ksize = 3, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1,
<a name="l00384"></a>00384                       <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00385"></a>00385 
<a name="l00387"></a>00387 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acfff38ecb8e7f5bd361fae17a7cc14c5" title="applies the vertical or horizontal Scharr operator to the image">Scharr</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1,
<a name="l00388"></a>00388                        <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00389"></a>00389 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acfff38ecb8e7f5bd361fae17a7cc14c5" title="applies the vertical or horizontal Scharr operator to the image">Scharr</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, GpuMat&amp; buf, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1,
<a name="l00390"></a>00390                        <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00391"></a>00391 
<a name="l00393"></a>00393 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab079e73b27591b4df3f87c8417a62139" title="smooths the image using Gaussian filter.">GaussianBlur</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a> ksize, <span class="keywordtype">double</span> sigma1, <span class="keywordtype">double</span> sigma2 = 0,
<a name="l00394"></a>00394                              <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1);
<a name="l00395"></a>00395 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab079e73b27591b4df3f87c8417a62139" title="smooths the image using Gaussian filter.">GaussianBlur</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a> ksize, GpuMat&amp; buf, <span class="keywordtype">double</span> sigma1, <span class="keywordtype">double</span> sigma2 = 0,
<a name="l00396"></a>00396                              <span class="keywordtype">int</span> rowBorderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <span class="keywordtype">int</span> columnBorderType = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00397"></a>00397 
<a name="l00400"></a>00400 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae4a4934d0c077a196d764c3dcf787283">Laplacian</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> ddepth, <span class="keywordtype">int</span> ksize = 1, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1, <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 
<a name="l00404"></a>00404 
<a name="l00406"></a>00406 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#abf9d5ed2316b0dcf1d4f7697ef4af5d8" title="implements generalized matrix product algorithm GEMM from BLAS">gemm</a>(<span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a897de4702c922f4cccda0d57ccdcafb3">src1</a>, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a7561a36d48069d54a6c8ac4e4750edfd">src2</a>, <span class="keywordtype">double</span> <a class="code" href="calib3d_8hpp.html#a95fc8341ca418bc06b36160632af6d47">alpha</a>,
<a name="l00407"></a>00407     <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a311f39c2d5ee53342a493cbed3d77de3">src3</a>, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a4bf45595b7df91ad095c49cf02ddee05">beta</a>, GpuMat&amp; dst, <span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#ae51e3a2d4365e85db9630dd3ce9508db">flags</a> = 0, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00408"></a>00408 
<a name="l00411"></a>00411 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a7cfec25a19b4236ca316a64273168e0a">transpose</a>(<span class="keyword">const</span> GpuMat&amp; src1, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00412"></a>00412 
<a name="l00415"></a>00415 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa857fbd6d39db313c2040f52bbcf0a0a">flip</a>(<span class="keyword">const</span> GpuMat&amp; <a class="code" href="legacy_8hpp.html#a1031d0e0a97a340abfe0a6ab9e831045">a</a>, GpuMat&amp; <a class="code" href="legacy_8hpp.html#ac04272e8ca865b8fba18d36edae9fd2a">b</a>, <span class="keywordtype">int</span> flipCode, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00416"></a>00416 
<a name="l00420"></a>00420 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a42994c029f61bfc25f7bb625a4e24e37">LUT</a>(<span class="keyword">const</span> GpuMat&amp; src, <span class="keyword">const</span> Mat&amp; <a class="code" href="core__c_8h.html#ac0182572699c7759eba7ba1d6b8e32d6">lut</a>, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00421"></a>00421 
<a name="l00423"></a>00423 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae68befc37dc085df80653f2a08da70e7" title="makes multi-channel array out of several single-channel arrays">merge</a>(<span class="keyword">const</span> GpuMat* src, <span class="keywordtype">size_t</span> <a class="code" href="legacy_8hpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00424"></a>00424 
<a name="l00426"></a>00426 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae68befc37dc085df80653f2a08da70e7" title="makes multi-channel array out of several single-channel arrays">merge</a>(<span class="keyword">const</span> vector&lt;GpuMat&gt;&amp; src, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00427"></a>00427 
<a name="l00429"></a>00429 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab43d16adf1bd20fb4cd5cd32cf8159cd" title="copies each plane of a multi-channel array to a dedicated array">split</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat* dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00430"></a>00430 
<a name="l00432"></a>00432 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab43d16adf1bd20fb4cd5cd32cf8159cd" title="copies each plane of a multi-channel array to a dedicated array">split</a>(<span class="keyword">const</span> GpuMat&amp; src, vector&lt;GpuMat&gt;&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00433"></a>00433 
<a name="l00436"></a>00436 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a635c000781dd2093cb63a5d94ae5a528">magnitude</a>(<span class="keyword">const</span> GpuMat&amp; xy, GpuMat&amp; <a class="code" href="namespacecv_1_1gpu.html#a635c000781dd2093cb63a5d94ae5a528">magnitude</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00437"></a>00437 
<a name="l00440"></a>00440 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a5e9109a6a14b77eed40bc0b196e234d4">magnitudeSqr</a>(<span class="keyword">const</span> GpuMat&amp; xy, GpuMat&amp; magnitude, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00441"></a>00441 
<a name="l00444"></a>00444 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a635c000781dd2093cb63a5d94ae5a528">magnitude</a>(<span class="keyword">const</span> GpuMat&amp; <a class="code" href="highgui__c_8h.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="highgui__c_8h.html#af1202c02b14870c18fb3a1da73e9e7c7">y</a>, GpuMat&amp; magnitude, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00445"></a>00445 
<a name="l00448"></a>00448 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a5e9109a6a14b77eed40bc0b196e234d4">magnitudeSqr</a>(<span class="keyword">const</span> GpuMat&amp; x, <span class="keyword">const</span> GpuMat&amp; y, GpuMat&amp; magnitude, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00449"></a>00449 
<a name="l00452"></a>00452 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab90b74a4cb60d9374fe7923a3cdd9b05">phase</a>(<span class="keyword">const</span> GpuMat&amp; x, <span class="keyword">const</span> GpuMat&amp; y, GpuMat&amp; <a class="code" href="core__c_8h.html#a00147158cd32c0f762ad7d5917e6d8fd">angle</a>, <span class="keywordtype">bool</span> angleInDegrees = <span class="keyword">false</span>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00453"></a>00453 
<a name="l00456"></a>00456 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#afcf48b88b32746d7888d98502a461d50">cartToPolar</a>(<span class="keyword">const</span> GpuMat&amp; x, <span class="keyword">const</span> GpuMat&amp; y, GpuMat&amp; magnitude, GpuMat&amp; angle, <span class="keywordtype">bool</span> angleInDegrees = <span class="keyword">false</span>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00457"></a>00457 
<a name="l00460"></a>00460 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0b38ef94850be1113ea9838d2d6490fc">polarToCart</a>(<span class="keyword">const</span> GpuMat&amp; magnitude, <span class="keyword">const</span> GpuMat&amp; angle, GpuMat&amp; x, GpuMat&amp; y, <span class="keywordtype">bool</span> angleInDegrees = <span class="keyword">false</span>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 
<a name="l00464"></a>00464 
<a name="l00466"></a>00466 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad04bf54d4fe4ef08ab013d3054c0322b" title="adds one matrix to another (c = a + b)">add</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; <a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a> = GpuMat(), <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00468"></a>00468 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad04bf54d4fe4ef08ab013d3054c0322b" title="adds one matrix to another (c = a + b)">add</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; c, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a> = GpuMat(), <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00469"></a>00469 
<a name="l00471"></a>00471 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#abcb4b7f5db9a5658a7079777541804d6" title="subtracts one matrix from another (c = a - b)">subtract</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a> = GpuMat(), <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00473"></a>00473 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#abcb4b7f5db9a5658a7079777541804d6" title="subtracts one matrix from another (c = a - b)">subtract</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; c, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a> = GpuMat(), <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00474"></a>00474 
<a name="l00476"></a>00476 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a5aa3670aed86f67799f31f841207ae18" title="computes element-wise weighted product of the two arrays (c = scale * a * b)">multiply</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1, <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00478"></a>00478 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a5aa3670aed86f67799f31f841207ae18" title="computes element-wise weighted product of the two arrays (c = scale * a * b)">multiply</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; c, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1, <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00479"></a>00479 
<a name="l00481"></a>00481 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#af5993fa1fd1d9652771f98c5588cdeed" title="computes element-wise weighted quotient of the two arrays (c = a / b)">divide</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1, <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00483"></a>00483 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#af5993fa1fd1d9652771f98c5588cdeed" title="computes element-wise weighted quotient of the two arrays (c = a / b)">divide</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; c, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a> = 1, <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00485"></a>00485 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#af5993fa1fd1d9652771f98c5588cdeed" title="computes element-wise weighted quotient of the two arrays (c = a / b)">divide</a>(<span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a6cf5c9eed7945265b2ed48f38d6a5424">scale</a>, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00486"></a>00486 
<a name="l00488"></a>00488 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a30cb3e79cf515fb1ec25a31967b1bab3" title="computes the weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)">addWeighted</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keywordtype">double</span> alpha, <span class="keyword">const</span> GpuMat&amp; src2, <span class="keywordtype">double</span> beta, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a8e2b334f37aeebfb12dc05106294a198">gamma</a>, GpuMat&amp; dst,
<a name="l00489"></a>00489                             <span class="keywordtype">int</span> dtype = -1, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00490"></a>00490 
<a name="l00492"></a>00492 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> scaleAdd(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keywordtype">double</span> alpha, <span class="keyword">const</span> GpuMat&amp; src2, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>())
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494     <a class="code" href="namespacecv_1_1gpu.html#a30cb3e79cf515fb1ec25a31967b1bab3" title="computes the weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)">addWeighted</a>(src1, alpha, src2, 1.0, 0.0, dst, -1, stream);
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00498"></a>00498 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ac9278c63dd1bd27f4ebe5e965b361cb4" title="computes element-wise absolute difference of two arrays (c = abs(a - b))">absdiff</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00500"></a>00500 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ac9278c63dd1bd27f4ebe5e965b361cb4" title="computes element-wise absolute difference of two arrays (c = abs(a - b))">absdiff</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; s, GpuMat&amp; c, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00501"></a>00501 
<a name="l00504"></a>00504 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad5b2b7dea0c16819ab3f7f3c2e8ca75b">abs</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00505"></a>00505 
<a name="l00508"></a>00508 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a103f8d8b38e54200259c9fa9b8bf5c3c">sqr</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00509"></a>00509 
<a name="l00512"></a>00512 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a73913b88b3c35a33adbdec598b84ea73">sqrt</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00513"></a>00513 
<a name="l00516"></a>00516 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a8665185517f099af5259b99568e735f5">exp</a>(<span class="keyword">const</span> GpuMat&amp; a, GpuMat&amp; b, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00517"></a>00517 
<a name="l00520"></a>00520 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a775af75f16f5979c2a11fceebd8133d4">log</a>(<span class="keyword">const</span> GpuMat&amp; a, GpuMat&amp; b, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00521"></a>00521 
<a name="l00523"></a>00523 <span class="comment">//    (dst(i,j) = pow(     src(i,j) , power), if src.type() is integer</span>
<a name="l00524"></a>00524 <span class="comment">//    (dst(i,j) = pow(fabs(src(i,j)), power), otherwise</span>
<a name="l00526"></a>00526 <span class="comment"></span>CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a73a81ba0a15d1575a7f83abb657ded24" title="computes power of each matrix element:">pow</a>(<span class="keyword">const</span> GpuMat&amp; src, <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#aa416d410b7e57a149726c660afcf7ddb">power</a>, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00527"></a>00527 
<a name="l00529"></a>00529 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a9d383d70bc30ddc96040e68ea69dfd32" title="compares elements of two arrays (c = a &lt;cmpop&gt; b)">compare</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keywordtype">int</span> cmpop, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00530"></a>00530 
<a name="l00532"></a>00532 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae2bc5b749e6c759666097f514fb003be" title="performs per-elements bit-wise inversion">bitwise_not</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>=GpuMat(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00533"></a>00533 
<a name="l00535"></a>00535 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa64153d4ffad093ed7a72e57bfc6d9f3" title="calculates per-element bit-wise disjunction of two arrays">bitwise_or</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> GpuMat&amp; src2, GpuMat&amp; dst, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>=GpuMat(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00538"></a>00538 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa64153d4ffad093ed7a72e57bfc6d9f3" title="calculates per-element bit-wise disjunction of two arrays">bitwise_or</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00539"></a>00539 
<a name="l00541"></a>00541 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0a780eb333321158a41ebdc68e014816" title="calculates per-element bit-wise conjunction of two arrays">bitwise_and</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> GpuMat&amp; src2, GpuMat&amp; dst, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>=GpuMat(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00544"></a>00544 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0a780eb333321158a41ebdc68e014816" title="calculates per-element bit-wise conjunction of two arrays">bitwise_and</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00545"></a>00545 
<a name="l00547"></a>00547 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a769b2863b6c2c95d671e9c85a9f05757" title="calculates per-element bit-wise &quot;exclusive or&quot; operation">bitwise_xor</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> GpuMat&amp; src2, GpuMat&amp; dst, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>=GpuMat(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00550"></a>00550 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a769b2863b6c2c95d671e9c85a9f05757" title="calculates per-element bit-wise &quot;exclusive or&quot; operation">bitwise_xor</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>&amp; sc, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00551"></a>00551 
<a name="l00554"></a>00554 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad37b179aebc3beb5eef36fc7d181c97c">rshift</a>(<span class="keyword">const</span> GpuMat&amp; src, Scalar_&lt;int&gt; sc, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00555"></a>00555 
<a name="l00558"></a>00558 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa71657c88a0fd845d45a354a82100935">lshift</a>(<span class="keyword">const</span> GpuMat&amp; src, Scalar_&lt;int&gt; sc, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00559"></a>00559 
<a name="l00561"></a>00561 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a8d100341ab11a730a3c90b75d5890a8c" title="computes per-element minimum of two arrays (dst = min(src1, src2))">min</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> GpuMat&amp; src2, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00562"></a>00562 
<a name="l00564"></a>00564 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a8d100341ab11a730a3c90b75d5890a8c" title="computes per-element minimum of two arrays (dst = min(src1, src2))">min</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keywordtype">double</span> src2, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00565"></a>00565 
<a name="l00567"></a>00567 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a706c9def6816de566be2671b75ec5309" title="computes per-element maximum of two arrays (dst = max(src1, src2))">max</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keyword">const</span> GpuMat&amp; src2, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00568"></a>00568 
<a name="l00570"></a>00570 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a706c9def6816de566be2671b75ec5309" title="computes per-element maximum of two arrays (dst = max(src1, src2))">max</a>(<span class="keyword">const</span> GpuMat&amp; src1, <span class="keywordtype">double</span> src2, GpuMat&amp; dst, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00571"></a>00571 
<a name="l00572"></a><a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a8889bd47ac8a6c7977fc7c861711adf0">00572</a> <span class="keyword">enum</span> { <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16abccb43ccacaa54402b9c1dbb9f340b3b">ALPHA_OVER</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a85ef6abbe17310899c1c0fb4651beed4">ALPHA_IN</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16ae2551abfe219198bee3ceff503a6570e">ALPHA_OUT</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a9c0cd530b49f0a10f0c84d1f223f334b">ALPHA_ATOP</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a8889bd47ac8a6c7977fc7c861711adf0">ALPHA_XOR</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16ab2b27f06e659b2f3c079781fa1af22fa">ALPHA_PLUS</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16ad7595c90d951a320af1dce8bc8bf76dd">ALPHA_OVER_PREMUL</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a6243fed75145acaae5c4c899c5b113c3">ALPHA_IN_PREMUL</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16af0edef3d595e5f9e0a55827160eeabf6">ALPHA_OUT_PREMUL</a>,
<a name="l00573"></a><a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a08df68bd727d5ff4fef75f16caaf902e">00573</a>        <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16ac20e13a1633b0e2a4cb796fc04e9aa62">ALPHA_ATOP_PREMUL</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a08df68bd727d5ff4fef75f16caaf902e">ALPHA_XOR_PREMUL</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a6d67271da02e6cba6e762dae312d3665">ALPHA_PLUS_PREMUL</a>, <a class="code" href="namespacecv_1_1gpu.html#a99d81dd1dfd35cb882c7b4830e956d16a13a77c0503755172fd5dcf7963c7ac11">ALPHA_PREMUL</a>};
<a name="l00574"></a>00574 
<a name="l00577"></a>00577 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa9da6f29377d091202616893fe055642">alphaComp</a>(<span class="keyword">const</span> GpuMat&amp; img1, <span class="keyword">const</span> GpuMat&amp; img2, GpuMat&amp; dst, <span class="keywordtype">int</span> alpha_op, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00581"></a>00581 
<a name="l00584"></a>00584 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a6043a8a9e72066a079e6b39939d4d997">remap</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> GpuMat&amp; xmap, <span class="keyword">const</span> GpuMat&amp; ymap,
<a name="l00585"></a>00585                       <span class="keywordtype">int</span> interpolation, <span class="keywordtype">int</span> borderMode = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422aed2e4346047e265c8c5a6d0276dcd838">BORDER_CONSTANT</a>, <a class="code" href="classcv_1_1_scalar__.html" title="The template scalar class.">Scalar</a> borderValue = <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>(),
<a name="l00586"></a>00586                       Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00587"></a>00587 
<a name="l00589"></a>00589 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ac6fb3aff49f1873855d0c5318f0c5b43" title="Does mean shift filtering on GPU.">meanShiftFiltering</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#ac14bc2e984efdff6b1fa7e106f3ac14a">sp</a>, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#acecaf9a0f96f944ff768b10358b45839">sr</a>,
<a name="l00590"></a>00590                                    <a class="code" href="classcv_1_1_term_criteria.html" title="Termination criteria in iterative algorithms.">TermCriteria</a> <a class="code" href="calib3d_8hpp.html#ac10fcea99ab081e745366c6f5bbc8eb5">criteria</a> = <a class="code" href="classcv_1_1_term_criteria.html" title="Termination criteria in iterative algorithms.">TermCriteria</a>(<a class="code" href="classcv_1_1_term_criteria.html#a8fc578554bd60c5ecbdc98b742641331a56ca2bc5cd06345060a1c1c66a8fc06e" title="ditto">TermCriteria::MAX_ITER</a> + <a class="code" href="classcv_1_1_term_criteria.html#a8fc578554bd60c5ecbdc98b742641331a857609e73e7028e638d2ea649f3b45d5" title="the desired accuracy or change in parameters at which the iterative algorithm stops">TermCriteria::EPS</a>, 5, 1),
<a name="l00591"></a>00591                                    Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00592"></a>00592 
<a name="l00594"></a>00594 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae2c4dc45950c634896af05b9a5087b39" title="Does mean shift procedure on GPU.">meanShiftProc</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dstr, GpuMat&amp; dstsp, <span class="keywordtype">int</span> sp, <span class="keywordtype">int</span> sr,
<a name="l00595"></a>00595                               <a class="code" href="classcv_1_1_term_criteria.html" title="Termination criteria in iterative algorithms.">TermCriteria</a> <a class="code" href="calib3d_8hpp.html#ac10fcea99ab081e745366c6f5bbc8eb5">criteria</a> = <a class="code" href="classcv_1_1_term_criteria.html" title="Termination criteria in iterative algorithms.">TermCriteria</a>(<a class="code" href="classcv_1_1_term_criteria.html#a8fc578554bd60c5ecbdc98b742641331a56ca2bc5cd06345060a1c1c66a8fc06e" title="ditto">TermCriteria::MAX_ITER</a> + <a class="code" href="classcv_1_1_term_criteria.html#a8fc578554bd60c5ecbdc98b742641331a857609e73e7028e638d2ea649f3b45d5" title="the desired accuracy or change in parameters at which the iterative algorithm stops">TermCriteria::EPS</a>, 5, 1),
<a name="l00596"></a>00596                               Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00597"></a>00597 
<a name="l00599"></a>00599 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a71ab42839dd13a7c9ee84abe91ddb471" title="Does mean shift segmentation with elimination of small regions.">meanShiftSegmentation</a>(<span class="keyword">const</span> GpuMat&amp; src, <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; dst, <span class="keywordtype">int</span> sp, <span class="keywordtype">int</span> sr, <span class="keywordtype">int</span> minsize,
<a name="l00600"></a>00600                                       <a class="code" href="classcv_1_1_term_criteria.html" title="Termination criteria in iterative algorithms.">TermCriteria</a> <a class="code" href="calib3d_8hpp.html#ac10fcea99ab081e745366c6f5bbc8eb5">criteria</a> = <a class="code" href="classcv_1_1_term_criteria.html" title="Termination criteria in iterative algorithms.">TermCriteria</a>(<a class="code" href="classcv_1_1_term_criteria.html#a8fc578554bd60c5ecbdc98b742641331a56ca2bc5cd06345060a1c1c66a8fc06e" title="ditto">TermCriteria::MAX_ITER</a> + <a class="code" href="classcv_1_1_term_criteria.html#a8fc578554bd60c5ecbdc98b742641331a857609e73e7028e638d2ea649f3b45d5" title="the desired accuracy or change in parameters at which the iterative algorithm stops">TermCriteria::EPS</a>, 5, 1));
<a name="l00601"></a>00601 
<a name="l00605"></a>00605 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#addc62c4b5e8d600e649c100c2852ccf9">drawColorDisp</a>(<span class="keyword">const</span> GpuMat&amp; src_disp, GpuMat&amp; dst_disp, <span class="keywordtype">int</span> ndisp, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00606"></a>00606 
<a name="l00612"></a>00612 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a01e276592a2b8857754e3edee887b2d9">reprojectImageTo3D</a>(<span class="keyword">const</span> GpuMat&amp; disp, GpuMat&amp; xyzw, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; <a class="code" href="calib3d_8hpp.html#a29d14baac63d86e6bbb0b03861384e2c">Q</a>, <span class="keywordtype">int</span> dst_cn = 4, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00613"></a>00613 
<a name="l00615"></a>00615 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aab8e9ff3ec24f52a104fc1bd80bdb10f" title="converts image from one color space to another">cvtColor</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a9a9fd13fa1f888f8baeda154bb1a3691">code</a>, <span class="keywordtype">int</span> dcn = 0, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00616"></a>00616 
<a name="l00622"></a>00622 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a3de8e8474bc3d66155041366d0628535">swapChannels</a>(GpuMat&amp; <a class="code" href="highgui__c_8h.html#a35b1e6246c0baa4fe7c8a916316d3adc">image</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> dstOrder[4], Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00623"></a>00623 
<a name="l00625"></a>00625 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a095a8ef06ce75a9646bb86437f47a5a0" title="Routines for correcting image color gamma.">gammaCorrection</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">bool</span> forward = <span class="keyword">true</span>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00626"></a>00626 
<a name="l00628"></a>00628 CV_EXPORTS <span class="keywordtype">double</span> <a class="code" href="namespacecv_1_1gpu.html#a63944c7054df081596be6b4cf94df871" title="applies fixed threshold to the image">threshold</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">double</span> thresh, <span class="keywordtype">double</span> maxval, <span class="keywordtype">int</span> type, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00629"></a>00629 
<a name="l00632"></a>00632 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a521d642cc1410137c0b8538ac5ccac42">resize</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dsize, <span class="keywordtype">double</span> fx=0, <span class="keywordtype">double</span> fy=0, <span class="keywordtype">int</span> interpolation = <a class="code" href="namespacecv.html#acee05c80e216c13e7bc2c0304447e554ac97d8e4880d8b5d509e96825c7522deb" title="bilinear interpolation">INTER_LINEAR</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00633"></a>00633 
<a name="l00636"></a>00636 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ade9767f511c582ee0e024a081afd946c">warpAffine</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; <a class="code" href="imgproc__c_8h.html#a404a4d60c53041fc1a1cd804d1c07cbb">M</a>, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dsize, <span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#ae51e3a2d4365e85db9630dd3ce9508db">flags</a> = <a class="code" href="namespacecv.html#acee05c80e216c13e7bc2c0304447e554ac97d8e4880d8b5d509e96825c7522deb" title="bilinear interpolation">INTER_LINEAR</a>,
<a name="l00637"></a>00637     <span class="keywordtype">int</span> borderMode = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422aed2e4346047e265c8c5a6d0276dcd838">BORDER_CONSTANT</a>, <a class="code" href="classcv_1_1_scalar__.html" title="The template scalar class.">Scalar</a> borderValue = <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ac0fee3d77db35b68c7e9e151095fcab5">buildWarpAffineMaps</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; M, <span class="keywordtype">bool</span> inverse, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dsize, GpuMat&amp; xmap, GpuMat&amp; ymap, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00640"></a>00640 
<a name="l00643"></a>00643 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a7278d07b1e25c1e29d4716f955ea2ab7">warpPerspective</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; M, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dsize, <span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#ae51e3a2d4365e85db9630dd3ce9508db">flags</a> = <a class="code" href="namespacecv.html#acee05c80e216c13e7bc2c0304447e554ac97d8e4880d8b5d509e96825c7522deb" title="bilinear interpolation">INTER_LINEAR</a>,
<a name="l00644"></a>00644     <span class="keywordtype">int</span> borderMode = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422aed2e4346047e265c8c5a6d0276dcd838">BORDER_CONSTANT</a>, <a class="code" href="classcv_1_1_scalar__.html" title="The template scalar class.">Scalar</a> borderValue = <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a9f33a63ee99d5b520cd9b8418f58bdd0">buildWarpPerspectiveMaps</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; M, <span class="keywordtype">bool</span> inverse, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dsize, GpuMat&amp; xmap, GpuMat&amp; ymap, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00647"></a>00647 
<a name="l00649"></a>00649 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab9417fe8aa259dd95c640e28196de353" title="builds plane warping maps">buildWarpPlaneMaps</a>(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> src_size, <a class="code" href="classcv_1_1_rect__.html">Rect</a> dst_roi, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> &amp;K, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; <a class="code" href="calib3d_8hpp.html#a2ea7d948846e496014d0468ad2c8807f">R</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> &amp;<a class="code" href="calib3d_8hpp.html#a3efb9551a871ddd0463079a808916717">T</a>, <span class="keywordtype">float</span> scale,
<a name="l00650"></a>00650                                    GpuMat&amp; map_x, GpuMat&amp; map_y, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00651"></a>00651 
<a name="l00653"></a>00653 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a1fcc8d1c094833058e95122dc4670669" title="builds cylindrical warping maps">buildWarpCylindricalMaps</a>(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> src_size, <a class="code" href="classcv_1_1_rect__.html">Rect</a> dst_roi, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> &amp;K, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; R, <span class="keywordtype">float</span> scale,
<a name="l00654"></a>00654                                          GpuMat&amp; map_x, GpuMat&amp; map_y, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00655"></a>00655 
<a name="l00657"></a>00657 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a1eddcfde971cec61b4a06153607c670f" title="builds spherical warping maps">buildWarpSphericalMaps</a>(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> src_size, <a class="code" href="classcv_1_1_rect__.html">Rect</a> dst_roi, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> &amp;K, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; R, <span class="keywordtype">float</span> scale,
<a name="l00658"></a>00658                                        GpuMat&amp; map_x, GpuMat&amp; map_y, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00659"></a>00659 
<a name="l00663"></a>00663 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a9a754d4e24ef674789858af05942980b">rotate</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dsize, <span class="keywordtype">double</span> angle, <span class="keywordtype">double</span> xShift = 0, <span class="keywordtype">double</span> yShift = 0,
<a name="l00664"></a>00664                        <span class="keywordtype">int</span> interpolation = <a class="code" href="namespacecv.html#acee05c80e216c13e7bc2c0304447e554ac97d8e4880d8b5d509e96825c7522deb" title="bilinear interpolation">INTER_LINEAR</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00665"></a>00665 
<a name="l00667"></a>00667 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a44caac13f69340101faf8eccaa1efe27" title="copies 2D array to a larger destination array and pads borders with user-specifiable constant...">copyMakeBorder</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> top, <span class="keywordtype">int</span> bottom, <span class="keywordtype">int</span> left, <span class="keywordtype">int</span> <a class="code" href="calib3d_8hpp.html#a6b04b878081bf724144b73c75dfd1894">right</a>, <span class="keywordtype">int</span> borderType,
<a name="l00668"></a>00668                                <span class="keyword">const</span> <a class="code" href="classcv_1_1_scalar__.html" title="The template scalar class.">Scalar</a>&amp; <a class="code" href="core__c_8h.html#ad4670c92695d4327c21292905a803901">value</a> = <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>(), Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00669"></a>00669 
<a name="l00673"></a>00673 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a23274e16c4795ffcb786107b71cfb70a">integral</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; <a class="code" href="namespacecv_1_1gpu.html#a5292ab871ffc965df3968dbe6b9f7b20">sum</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00675"></a>00675 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a06b669ddbbb8134df5655dca1334863b" title="buffered version">integralBuffered</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; sum, GpuMat&amp; <a class="code" href="imgproc__c_8h.html#ac9db6ccf8d1a2abfd9a0a162547f9666">buffer</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00676"></a>00676 
<a name="l00680"></a>00680 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a1b68a581f3d74a8f7ef28ac7a430aff1">sqrIntegral</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; <a class="code" href="namespacecv.html#a0bd30d74bcc3d062f08aca5eb296c05e">sqsum</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00681"></a>00681 
<a name="l00683"></a>00683 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a3794819b6a8cb137837dfa1cd1be8439" title="computes vertical sum, supports only CV_32FC1 images">columnSum</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; sum);
<a name="l00684"></a>00684 
<a name="l00688"></a>00688 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#afbf9bd1ae2c863760247cde366350c25">rectStdDev</a>(<span class="keyword">const</span> GpuMat&amp; src, <span class="keyword">const</span> GpuMat&amp; <a class="code" href="namespacecv_1_1gpu.html#a103f8d8b38e54200259c9fa9b8bf5c3c">sqr</a>, GpuMat&amp; dst, <span class="keyword">const</span> <a class="code" href="classcv_1_1_rect__.html">Rect</a>&amp; <a class="code" href="core__c_8h.html#a530a78d59bfb8d13c3013626ebb95c2e">rect</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00689"></a>00689 
<a name="l00691"></a>00691 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab8cc2728fe72db1c51045c05ae7c4142" title="computes Harris cornerness criteria at each image pixel">cornerHarris</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> ksize, <span class="keywordtype">double</span> <a class="code" href="legacy_8hpp.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>, <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422a119fb22eda11675d2e00426d334a1a81">BORDER_REFLECT101</a>);
<a name="l00692"></a>00692 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab8cc2728fe72db1c51045c05ae7c4142" title="computes Harris cornerness criteria at each image pixel">cornerHarris</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, GpuMat&amp; Dx, GpuMat&amp; Dy, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> ksize, <span class="keywordtype">double</span> <a class="code" href="legacy_8hpp.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>, <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422a119fb22eda11675d2e00426d334a1a81">BORDER_REFLECT101</a>);
<a name="l00693"></a>00693 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab8cc2728fe72db1c51045c05ae7c4142" title="computes Harris cornerness criteria at each image pixel">cornerHarris</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, GpuMat&amp; Dx, GpuMat&amp; Dy, GpuMat&amp; buf, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> ksize, <span class="keywordtype">double</span> <a class="code" href="legacy_8hpp.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>,
<a name="l00694"></a>00694                              <span class="keywordtype">int</span> borderType = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422a119fb22eda11675d2e00426d334a1a81">BORDER_REFLECT101</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00695"></a>00695 
<a name="l00697"></a>00697 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a276e83d391b545ae9d7572fd9424df64" title="computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness crit...">cornerMinEigenVal</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> ksize, <span class="keywordtype">int</span> borderType=<a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422a119fb22eda11675d2e00426d334a1a81">BORDER_REFLECT101</a>);
<a name="l00698"></a>00698 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a276e83d391b545ae9d7572fd9424df64" title="computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness crit...">cornerMinEigenVal</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, GpuMat&amp; Dx, GpuMat&amp; Dy, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> ksize, <span class="keywordtype">int</span> borderType=<a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422a119fb22eda11675d2e00426d334a1a81">BORDER_REFLECT101</a>);
<a name="l00699"></a>00699 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a276e83d391b545ae9d7572fd9424df64" title="computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness crit...">cornerMinEigenVal</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, GpuMat&amp; Dx, GpuMat&amp; Dy, GpuMat&amp; buf, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> ksize,
<a name="l00700"></a>00700     <span class="keywordtype">int</span> borderType=<a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422a119fb22eda11675d2e00426d334a1a81">BORDER_REFLECT101</a>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00701"></a>00701 
<a name="l00704"></a>00704 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a1d7bcdd6c44eddcc58af6e708232cf02">mulSpectrums</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#ae51e3a2d4365e85db9630dd3ce9508db">flags</a>, <span class="keywordtype">bool</span> conjB=<span class="keyword">false</span>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00705"></a>00705 
<a name="l00708"></a>00708 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa3954dc028c083dc37ded6774ab8d86d">mulAndScaleSpectrums</a>(<span class="keyword">const</span> GpuMat&amp; a, <span class="keyword">const</span> GpuMat&amp; b, GpuMat&amp; c, <span class="keywordtype">int</span> flags, <span class="keywordtype">float</span> scale, <span class="keywordtype">bool</span> conjB=<span class="keyword">false</span>, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00709"></a>00709 
<a name="l00721"></a>00721 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ac30c21fa878691ae18638ff0841e6a09">dft</a>(<span class="keyword">const</span> GpuMat&amp; src, GpuMat&amp; dst, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> dft_size, <span class="keywordtype">int</span> flags=0, Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00722"></a>00722 
<a name="l00723"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html">00723</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html">ConvolveBuf</a>
<a name="l00724"></a>00724 {
<a name="l00725"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a1fcc3ca5bfa580528118ce922b3692b7">00725</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a1fcc3ca5bfa580528118ce922b3692b7">result_size</a>;
<a name="l00726"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a6aef44d6f244fddaf0af4200872deacc">00726</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a6aef44d6f244fddaf0af4200872deacc">block_size</a>;
<a name="l00727"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#ade057847a290ec2248bd3b2cfca3d917">00727</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#ade057847a290ec2248bd3b2cfca3d917">user_block_size</a>;
<a name="l00728"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a5593bfd0e5bd9eb4f72a3c97a77a2c63">00728</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a5593bfd0e5bd9eb4f72a3c97a77a2c63">dft_size</a>;
<a name="l00729"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a300e36466a351f57ac879152dc38b7e0">00729</a>     <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a300e36466a351f57ac879152dc38b7e0">spect_len</a>;
<a name="l00730"></a>00730 
<a name="l00731"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a35ceeee1b84fbde044e518ea5237ad97">00731</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> image_spect, <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#a35ceeee1b84fbde044e518ea5237ad97">templ_spect</a>, result_spect;
<a name="l00732"></a><a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#ae6c09a39fbd299368b18a7f95de072d8">00732</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> image_block, <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html#ae6c09a39fbd299368b18a7f95de072d8">templ_block</a>, result_data;
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     <span class="keywordtype">void</span> create(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="calib3d_8hpp.html#a3c5695da25794e723582c8b5ccff544c">image_size</a>, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> templ_size);
<a name="l00735"></a>00735     <span class="keyword">static</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> estimateBlockSize(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> result_size, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> templ_size);
<a name="l00736"></a>00736 };
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 
<a name="l00742"></a>00742 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acedc0610e0ef2aa3673d43c4d8ff6058">convolve</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a3dda0ce9b269462404396ce3e9eedf00">templ</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a14871c176a686a03035b5f2bbc72a63f">result</a>, <span class="keywordtype">bool</span> ccorr = <span class="keyword">false</span>);
<a name="l00743"></a>00743 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#acedc0610e0ef2aa3673d43c4d8ff6058">convolve</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a3dda0ce9b269462404396ce3e9eedf00">templ</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a14871c176a686a03035b5f2bbc72a63f">result</a>, <span class="keywordtype">bool</span> ccorr, <a class="code" href="structcv_1_1gpu_1_1_convolve_buf.html">ConvolveBuf</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00744"></a>00744 
<a name="l00745"></a><a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html">00745</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html">MatchTemplateBuf</a>
<a name="l00746"></a>00746 {
<a name="l00747"></a><a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#a3224af1c66c84536181d5bcdd9007339">00747</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#a3224af1c66c84536181d5bcdd9007339">user_block_size</a>;
<a name="l00748"></a><a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#ab0a5afc2f6a35edcf453fd77f878d596">00748</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> imagef, <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#ab0a5afc2f6a35edcf453fd77f878d596">templf</a>;
<a name="l00749"></a><a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#ae12cf962682edaea5914cb3d8a53b7eb">00749</a>     std::vector&lt;GpuMat&gt; <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#ae12cf962682edaea5914cb3d8a53b7eb">images</a>;
<a name="l00750"></a><a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#aba37eb8859e38df75ec1632875c00b40">00750</a>     std::vector&lt;GpuMat&gt; <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#aba37eb8859e38df75ec1632875c00b40">image_sums</a>;
<a name="l00751"></a><a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#a5c5e8f5ed03328f27921ef1b0b361ad7">00751</a>     std::vector&lt;GpuMat&gt; <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html#a5c5e8f5ed03328f27921ef1b0b361ad7">image_sqsums</a>;
<a name="l00752"></a>00752 };
<a name="l00753"></a>00753 
<a name="l00755"></a>00755 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aaee18beb5678a4bdf95eb3082aabd92a" title="computes the proximity map for the raster template and the image where the template is searched for...">matchTemplate</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; templ, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; result, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#ab9b9819cc20b34aa0ae2bfa4486e7a65">method</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a> &amp;stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00756"></a>00756 
<a name="l00758"></a>00758 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aaee18beb5678a4bdf95eb3082aabd92a" title="computes the proximity map for the raster template and the image where the template is searched for...">matchTemplate</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; templ, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; result, <span class="keywordtype">int</span> method, <a class="code" href="structcv_1_1gpu_1_1_match_template_buf.html">MatchTemplateBuf</a> &amp;buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00759"></a>00759 
<a name="l00761"></a>00761 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad5b29e2b442c4a32e2d9abfa47c6a7dd" title="smoothes the source image and downsamples it">pyrDown</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00762"></a>00762 
<a name="l00764"></a>00764 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a716abedb17a5b8a2cc598c7caa709c82" title="upsamples the source image and then smoothes it">pyrUp</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00765"></a>00765 
<a name="l00768"></a>00768 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#abebc3a4b8dd6bc54f138208ba2f71d66">blendLinear</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img1, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img2, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; weights1, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; weights2,
<a name="l00769"></a>00769                             <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; result, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00770"></a>00770 
<a name="l00772"></a>00772 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a78e25a4694624715be0f24e182c81e7b" title="Performa bilateral filtering of passsed image.">bilateralFilter</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <span class="keywordtype">int</span> kernel_size, <span class="keywordtype">float</span> sigma_color, <span class="keywordtype">float</span> sigma_spatial,
<a name="l00773"></a>00773                                 <span class="keywordtype">int</span> borderMode = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00774"></a>00774 
<a name="l00776"></a>00776 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a2d1705c90e1674ce1b9cc26f66c73b59" title="Brute force non-local means algorith (slow but universal)">nonLocalMeans</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <span class="keywordtype">float</span> h, <span class="keywordtype">int</span> search_window = 21, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a2d7c85a0cd4aeceb7043475ac38fe836">block_size</a> = 7, <span class="keywordtype">int</span> borderMode = <a class="code" href="namespacecv.html#af21931fd13eae9736e980dda0b4de422afe14c13a4ea8b8e3b3ef399013dbae01">BORDER_DEFAULT</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; s = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00777"></a>00777 
<a name="l00779"></a><a class="code" href="classcv_1_1gpu_1_1_fast_non_local_means_denoising.html">00779</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_fast_non_local_means_denoising.html" title="Fast (but approximate)version of non-local means algorith similar to CPU function (running sums techn...">FastNonLocalMeansDenoising</a>
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781 <span class="keyword">public</span>:
<a name="l00783"></a>00783     <span class="keywordtype">void</span> simpleMethod(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <span class="keywordtype">float</span> h, <span class="keywordtype">int</span> search_window = 21, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a2d7c85a0cd4aeceb7043475ac38fe836">block_size</a> = 7, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; s = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00784"></a>00784 
<a name="l00786"></a>00786     <span class="keywordtype">void</span> labMethod(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <span class="keywordtype">float</span> h_luminance, <span class="keywordtype">float</span> h_color, <span class="keywordtype">int</span> search_window = 21, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a2d7c85a0cd4aeceb7043475ac38fe836">block_size</a> = 7, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; s = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 <span class="keyword">private</span>:
<a name="l00789"></a>00789 
<a name="l00790"></a>00790     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="imgproc__c_8h.html#ac9db6ccf8d1a2abfd9a0a162547f9666">buffer</a>, extended_src_buffer;
<a name="l00791"></a>00791     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> lab, l, ab;
<a name="l00792"></a>00792 };
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 
<a name="l00795"></a><a class="code" href="namespacecv_1_1gpu.html#ab999a413b68ceaee0261569d65a19a56">00795</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">CannyBuf</a>;
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a99378c111eb415f3a9145a8ebb939488">Canny</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a0934986249e7ba69309a154af3260f89">edges</a>, <span class="keywordtype">double</span> low_thresh, <span class="keywordtype">double</span> high_thresh, <span class="keywordtype">int</span> apperture_size = 3, <span class="keywordtype">bool</span> L2gradient = <span class="keyword">false</span>);
<a name="l00798"></a>00798 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a99378c111eb415f3a9145a8ebb939488">Canny</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">CannyBuf</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a0934986249e7ba69309a154af3260f89">edges</a>, <span class="keywordtype">double</span> low_thresh, <span class="keywordtype">double</span> high_thresh, <span class="keywordtype">int</span> apperture_size = 3, <span class="keywordtype">bool</span> L2gradient = <span class="keyword">false</span>);
<a name="l00799"></a>00799 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a99378c111eb415f3a9145a8ebb939488">Canny</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a0934986249e7ba69309a154af3260f89">edges</a>, <span class="keywordtype">double</span> low_thresh, <span class="keywordtype">double</span> high_thresh, <span class="keywordtype">bool</span> L2gradient = <span class="keyword">false</span>);
<a name="l00800"></a>00800 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a99378c111eb415f3a9145a8ebb939488">Canny</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy, <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">CannyBuf</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a0934986249e7ba69309a154af3260f89">edges</a>, <span class="keywordtype">double</span> low_thresh, <span class="keywordtype">double</span> high_thresh, <span class="keywordtype">bool</span> L2gradient = <span class="keyword">false</span>);
<a name="l00801"></a>00801 
<a name="l00802"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">00802</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">CannyBuf</a>
<a name="l00803"></a>00803 {
<a name="l00804"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#a2788093ffe61d1af32484005a60c6211">00804</a>     <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#a2788093ffe61d1af32484005a60c6211">CannyBuf</a>() {}
<a name="l00805"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#af5a9c842d97c145fda247faafd9de5f4">00805</a>     <span class="keyword">explicit</span> <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#af5a9c842d97c145fda247faafd9de5f4">CannyBuf</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; <a class="code" href="calib3d_8hpp.html#a3c5695da25794e723582c8b5ccff544c">image_size</a>, <span class="keywordtype">int</span> apperture_size = 3) {create(image_size, apperture_size);}
<a name="l00806"></a>00806     <a class="code" href="namespacecv_1_1gpu.html#ab999a413b68ceaee0261569d65a19a56">CannyBuf</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx_, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy_);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808     <span class="keywordtype">void</span> create(<span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; <a class="code" href="calib3d_8hpp.html#a3c5695da25794e723582c8b5ccff544c">image_size</a>, <span class="keywordtype">int</span> apperture_size = 3);
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <span class="keywordtype">void</span> release();
<a name="l00811"></a>00811 
<a name="l00812"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#af6a87c2f0acf77054e2ba27f053aa587">00812</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> dx, <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#af6a87c2f0acf77054e2ba27f053aa587">dy</a>;
<a name="l00813"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#a0daa2eedb78fac42cc45b9ac3cacd48c">00813</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> dx_buf, <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#a0daa2eedb78fac42cc45b9ac3cacd48c">dy_buf</a>;
<a name="l00814"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#aa147448aff4fade62b81ad0473fe01d1">00814</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#aa147448aff4fade62b81ad0473fe01d1">edgeBuf</a>;
<a name="l00815"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#abdabe0cd8a3ae90f16b47098339fe83e">00815</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> trackBuf1, <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#abdabe0cd8a3ae90f16b47098339fe83e">trackBuf2</a>;
<a name="l00816"></a><a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#abbf4d1c0a9096fad24ba817c58943aa6">00816</a>     <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> filterDX, <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html#abbf4d1c0a9096fad24ba817c58943aa6">filterDY</a>;
<a name="l00817"></a>00817 };
<a name="l00818"></a>00818 
<a name="l00819"></a><a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html">00819</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html">ImagePyramid</a>
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821 <span class="keyword">public</span>:
<a name="l00822"></a><a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html#a3d5bb59a2aac09dfd542b9a4e805f0ad">00822</a>     <span class="keyword">inline</span> <a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html#a3d5bb59a2aac09dfd542b9a4e805f0ad">ImagePyramid</a>() : nLayers_(0) {}
<a name="l00823"></a><a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html#a68fb8a2ad9fb79b4290c4475c1bc04db">00823</a>     <span class="keyword">inline</span> <a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html">ImagePyramid</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="legacy_8hpp.html#a5349238b3772bed6eae0fda3117ccfef">img</a>, <span class="keywordtype">int</span> nLayers, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>())
<a name="l00824"></a>00824     {
<a name="l00825"></a>00825         build(img, nLayers, stream);
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828     <span class="keywordtype">void</span> build(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <span class="keywordtype">int</span> nLayers, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00829"></a>00829 
<a name="l00830"></a>00830     <span class="keywordtype">void</span> getLayer(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; outImg, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> outRoi, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) <span class="keyword">const</span>;
<a name="l00831"></a>00831 
<a name="l00832"></a><a class="code" href="classcv_1_1gpu_1_1_image_pyramid.html#a7c6de7ab90826b9cd597a34b7f93dfb7">00832</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> release()
<a name="l00833"></a>00833     {
<a name="l00834"></a>00834         layer0_.release();
<a name="l00835"></a>00835         pyramid_.clear();
<a name="l00836"></a>00836         nLayers_ = 0;
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 <span class="keyword">private</span>:
<a name="l00840"></a>00840     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> layer0_;
<a name="l00841"></a>00841     std::vector&lt;GpuMat&gt; pyramid_;
<a name="l00842"></a>00842     <span class="keywordtype">int</span> nLayers_;
<a name="l00843"></a>00843 };
<a name="l00844"></a>00844 
<a name="l00846"></a>00846 
<a name="l00847"></a><a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html">00847</a> <span class="keyword">struct </span><a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html" title="HoughLines.">HoughLinesBuf</a>
<a name="l00848"></a>00848 {
<a name="l00849"></a><a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html#ad804ccd2a956d2fba437dbf3570e7d9a">00849</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html#ad804ccd2a956d2fba437dbf3570e7d9a">accum</a>;
<a name="l00850"></a><a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html#a68c3b735dffff258359616608213ddc0">00850</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html#a68c3b735dffff258359616608213ddc0">list</a>;
<a name="l00851"></a>00851 };
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0a4b78050f189b5b7d8c429ab2c22ae5">HoughLines</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; lines, <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#a7d8783b6b909806d38134f1f342005bf">rho</a>, <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#a90ba48f41646a904a861746079d43f17">theta</a>, <span class="keywordtype">int</span> <a class="code" href="namespacecv_1_1gpu.html#a63944c7054df081596be6b4cf94df871" title="applies fixed threshold to the image">threshold</a>, <span class="keywordtype">bool</span> doSort = <span class="keyword">false</span>, <span class="keywordtype">int</span> maxLines = 4096);
<a name="l00854"></a>00854 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0a4b78050f189b5b7d8c429ab2c22ae5">HoughLines</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; lines, <a class="code" href="structcv_1_1gpu_1_1_hough_lines_buf.html" title="HoughLines.">HoughLinesBuf</a>&amp; buf, <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#a7d8783b6b909806d38134f1f342005bf">rho</a>, <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#a90ba48f41646a904a861746079d43f17">theta</a>, <span class="keywordtype">int</span> <a class="code" href="namespacecv_1_1gpu.html#a63944c7054df081596be6b4cf94df871" title="applies fixed threshold to the image">threshold</a>, <span class="keywordtype">bool</span> doSort = <span class="keyword">false</span>, <span class="keywordtype">int</span> maxLines = 4096);
<a name="l00855"></a>00855 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ab7c3d1403318e4fcd3d3efbe0b3957c2">HoughLinesDownload</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; d_lines, <a class="code" href="classcv_1_1___output_array.html" title="Proxy datatype for passing Mat&#39;s and vector&lt;&gt;&#39;s as input parameters.">OutputArray</a> h_lines, <a class="code" href="classcv_1_1___output_array.html" title="Proxy datatype for passing Mat&#39;s and vector&lt;&gt;&#39;s as input parameters.">OutputArray</a> h_votes = <a class="code" href="namespacecv.html#a34538a27d7f566fdff26b0484b2a9740">noArray</a>());
<a name="l00856"></a>00856 
<a name="l00858"></a>00858 
<a name="l00859"></a><a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html">00859</a> <span class="keyword">struct </span><a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html" title="HoughCircles.">HoughCirclesBuf</a>
<a name="l00860"></a>00860 {
<a name="l00861"></a><a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#ab839c1e51739fc2c5bd358828b39bcbd">00861</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#ab839c1e51739fc2c5bd358828b39bcbd">edges</a>;
<a name="l00862"></a><a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#a00fe9ce2a71b3d02060b9a97cb1cb2f3">00862</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#a00fe9ce2a71b3d02060b9a97cb1cb2f3">accum</a>;
<a name="l00863"></a><a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#ab2ea2af56aca0f063bbfe8434d462a76">00863</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#ab2ea2af56aca0f063bbfe8434d462a76">list</a>;
<a name="l00864"></a><a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#aa90bedc09cd2eba166b1883108a86541">00864</a>     <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">CannyBuf</a> <a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html#aa90bedc09cd2eba166b1883108a86541">cannyBuf</a>;
<a name="l00865"></a>00865 };
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a14a9ccff339680c7a1cb84dc88173926">HoughCircles</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; circles, <span class="keywordtype">int</span> method, <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#ab72596cdef510cb9cb1a2b07a9189912">dp</a>, <span class="keywordtype">float</span> minDist, <span class="keywordtype">int</span> cannyThreshold, <span class="keywordtype">int</span> votesThreshold, <span class="keywordtype">int</span> minRadius, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#aa127cf4ed721c001f0dd39efd29b9790">maxRadius</a>, <span class="keywordtype">int</span> maxCircles = 4096);
<a name="l00868"></a>00868 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a14a9ccff339680c7a1cb84dc88173926">HoughCircles</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; circles, <a class="code" href="structcv_1_1gpu_1_1_hough_circles_buf.html" title="HoughCircles.">HoughCirclesBuf</a>&amp; buf, <span class="keywordtype">int</span> method, <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#ab72596cdef510cb9cb1a2b07a9189912">dp</a>, <span class="keywordtype">float</span> minDist, <span class="keywordtype">int</span> cannyThreshold, <span class="keywordtype">int</span> votesThreshold, <span class="keywordtype">int</span> minRadius, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#aa127cf4ed721c001f0dd39efd29b9790">maxRadius</a>, <span class="keywordtype">int</span> maxCircles = 4096);
<a name="l00869"></a>00869 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ac8341096e9077b6274ab026a545d63ec">HoughCirclesDownload</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; d_circles, <a class="code" href="classcv_1_1___output_array.html" title="Proxy datatype for passing Mat&#39;s and vector&lt;&gt;&#39;s as input parameters.">OutputArray</a> h_circles);
<a name="l00870"></a>00870 
<a name="l00874"></a><a class="code" href="classcv_1_1gpu_1_1_generalized_hough___g_p_u.html">00874</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_generalized_hough___g_p_u.html">GeneralizedHough_GPU</a> : <span class="keyword">public</span> <a class="code" href="classcv_1_1_algorithm.html" title="Base class for high-level OpenCV algorithms.">Algorithm</a>
<a name="l00875"></a>00875 {
<a name="l00876"></a>00876 <span class="keyword">public</span>:
<a name="l00877"></a>00877     <span class="keyword">static</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">Ptr&lt;GeneralizedHough_GPU&gt;</a> create(<span class="keywordtype">int</span> method);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="keyword">virtual</span> ~<a class="code" href="classcv_1_1gpu_1_1_generalized_hough___g_p_u.html">GeneralizedHough_GPU</a>();
<a name="l00880"></a>00880 
<a name="l00882"></a>00882     <span class="keywordtype">void</span> setTemplate(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; templ, <span class="keywordtype">int</span> cannyThreshold = 100, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> templCenter = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1));
<a name="l00883"></a>00883     <span class="keywordtype">void</span> setTemplate(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#a0934986249e7ba69309a154af3260f89">edges</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> templCenter = <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a>(-1, -1));
<a name="l00884"></a>00884 
<a name="l00886"></a>00886     <span class="keywordtype">void</span> detect(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; positions, <span class="keywordtype">int</span> cannyThreshold = 100);
<a name="l00887"></a>00887     <span class="keywordtype">void</span> detect(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; edges, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; positions);
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     <span class="keywordtype">void</span> download(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; d_positions, <a class="code" href="classcv_1_1___output_array.html" title="Proxy datatype for passing Mat&#39;s and vector&lt;&gt;&#39;s as input parameters.">OutputArray</a> h_positions, <a class="code" href="classcv_1_1___output_array.html" title="Proxy datatype for passing Mat&#39;s and vector&lt;&gt;&#39;s as input parameters.">OutputArray</a> h_votes = <a class="code" href="namespacecv.html#a34538a27d7f566fdff26b0484b2a9740">noArray</a>());
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     <span class="keywordtype">void</span> release();
<a name="l00892"></a>00892 
<a name="l00893"></a>00893 <span class="keyword">protected</span>:
<a name="l00894"></a>00894     <span class="keyword">virtual</span> <span class="keywordtype">void</span> setTemplateImpl(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; edges, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a> templCenter) = 0;
<a name="l00895"></a>00895     <span class="keyword">virtual</span> <span class="keywordtype">void</span> detectImpl(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; edges, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; positions) = 0;
<a name="l00896"></a>00896     <span class="keyword">virtual</span> <span class="keywordtype">void</span> releaseImpl() = 0;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898 <span class="keyword">private</span>:
<a name="l00899"></a>00899     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> edges_;
<a name="l00900"></a>00900     <a class="code" href="structcv_1_1gpu_1_1_canny_buf.html">CannyBuf</a> cannyBuf_;
<a name="l00901"></a>00901 };
<a name="l00902"></a>00902 
<a name="l00904"></a>00904 
<a name="l00907"></a>00907 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#adc0eb419e9d30a0dae4cd37f027732b7">meanStdDev</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mtx, <a class="code" href="classcv_1_1_scalar__.html">Scalar</a>&amp; <a class="code" href="namespacecv.html#ae2494faec16b10931548dc4a04b8a9fa" title="computes mean value of selected array elements">mean</a>, <a class="code" href="classcv_1_1_scalar__.html">Scalar</a>&amp; stddev);
<a name="l00909"></a>00909 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#adc0eb419e9d30a0dae4cd37f027732b7">meanStdDev</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mtx, <a class="code" href="classcv_1_1_scalar__.html">Scalar</a>&amp; <a class="code" href="namespacecv.html#ae2494faec16b10931548dc4a04b8a9fa" title="computes mean value of selected array elements">mean</a>, <a class="code" href="classcv_1_1_scalar__.html">Scalar</a>&amp; stddev, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00910"></a>00910 
<a name="l00914"></a>00914 CV_EXPORTS <span class="keywordtype">double</span> <a class="code" href="namespacecv_1_1gpu.html#ae9da8cdd56d17c434f5f0a0414f70806">norm</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src1, <span class="keywordtype">int</span> normType=<a class="code" href="namespacecv.html#a0c6ff1c39c61dc19f4d07682001e7459a7bacbe84d400336a8f26297d8e80e3a2">NORM_L2</a>);
<a name="l00915"></a>00915 
<a name="l00919"></a>00919 CV_EXPORTS <span class="keywordtype">double</span> <a class="code" href="namespacecv_1_1gpu.html#ae9da8cdd56d17c434f5f0a0414f70806">norm</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src1, <span class="keywordtype">int</span> normType, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00920"></a>00920 
<a name="l00924"></a>00924 CV_EXPORTS <span class="keywordtype">double</span> <a class="code" href="namespacecv_1_1gpu.html#ae9da8cdd56d17c434f5f0a0414f70806">norm</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src1, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src2, <span class="keywordtype">int</span> normType=<a class="code" href="namespacecv.html#a0c6ff1c39c61dc19f4d07682001e7459a7bacbe84d400336a8f26297d8e80e3a2">NORM_L2</a>);
<a name="l00925"></a>00925 
<a name="l00928"></a>00928 CV_EXPORTS <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> <a class="code" href="namespacecv_1_1gpu.html#a5292ab871ffc965df3968dbe6b9f7b20">sum</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src);
<a name="l00929"></a>00929 
<a name="l00932"></a>00932 CV_EXPORTS <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> <a class="code" href="namespacecv_1_1gpu.html#a5292ab871ffc965df3968dbe6b9f7b20">sum</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00933"></a>00933 
<a name="l00936"></a>00936 CV_EXPORTS <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> <a class="code" href="namespacecv_1_1gpu.html#a06cb4f451f35058cb711e6deca0f4192">absSum</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src);
<a name="l00937"></a>00937 
<a name="l00940"></a>00940 CV_EXPORTS <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> <a class="code" href="namespacecv_1_1gpu.html#a06cb4f451f35058cb711e6deca0f4192">absSum</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00941"></a>00941 
<a name="l00944"></a>00944 CV_EXPORTS <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> <a class="code" href="namespacecv_1_1gpu.html#a37ab134ef3e842c914197089d705c384">sqrSum</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src);
<a name="l00945"></a>00945 
<a name="l00948"></a>00948 CV_EXPORTS <a class="code" href="classcv_1_1_scalar__.html">Scalar</a> <a class="code" href="namespacecv_1_1gpu.html#a37ab134ef3e842c914197089d705c384">sqrSum</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00949"></a>00949 
<a name="l00951"></a>00951 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a848e26ca95231f8902675855caf8a567" title="finds global minimum and maximum array elements and returns their values">minMax</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <span class="keywordtype">double</span>* minVal, <span class="keywordtype">double</span>* maxVal=0, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>=<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>());
<a name="l00952"></a>00952 
<a name="l00954"></a>00954 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a848e26ca95231f8902675855caf8a567" title="finds global minimum and maximum array elements and returns their values">minMax</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <span class="keywordtype">double</span>* minVal, <span class="keywordtype">double</span>* maxVal, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00955"></a>00955 
<a name="l00957"></a>00957 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a39ee438c6cd5a4841439188fe0fac448" title="finds global minimum and maximum array elements and returns their values with locations">minMaxLoc</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <span class="keywordtype">double</span>* minVal, <span class="keywordtype">double</span>* maxVal=0, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>* minLoc=0, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>* maxLoc=0,
<a name="l00958"></a>00958                           <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>=<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>());
<a name="l00959"></a>00959 
<a name="l00961"></a>00961 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a39ee438c6cd5a4841439188fe0fac448" title="finds global minimum and maximum array elements and returns their values with locations">minMaxLoc</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <span class="keywordtype">double</span>* minVal, <span class="keywordtype">double</span>* maxVal, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>* minLoc, <a class="code" href="classcv_1_1_point__.html" title="template 2D point class.">Point</a>* maxLoc,
<a name="l00962"></a>00962                           <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; valbuf, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; locbuf);
<a name="l00963"></a>00963 
<a name="l00965"></a>00965 CV_EXPORTS <span class="keywordtype">int</span> <a class="code" href="namespacecv_1_1gpu.html#aec527594d46c5b49dbe82fd9c1ed72da" title="counts non-zero array elements">countNonZero</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src);
<a name="l00966"></a>00966 
<a name="l00968"></a>00968 CV_EXPORTS <span class="keywordtype">int</span> <a class="code" href="namespacecv_1_1gpu.html#aec527594d46c5b49dbe82fd9c1ed72da" title="counts non-zero array elements">countNonZero</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l00969"></a>00969 
<a name="l00971"></a>00971 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a674736a7da871eaa103883407c4d839b" title="reduces a matrix to a vector">reduce</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mtx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; vec, <span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> reduceOp, <span class="keywordtype">int</span> dtype = -1, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a63a5cdc3242498687841990ffdaa303c">transformPoints</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; rvec, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; tvec,
<a name="l00977"></a>00977                                 <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a6144a51e8d6a8ec48a94b9053d69fb6e">projectPoints</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; rvec, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; tvec,
<a name="l00980"></a>00980                               <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; camera_mat, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; dist_coef, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst,
<a name="l00981"></a>00981                               <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a05d4663999c9d548c97f8d6d55401b6e">solvePnPRansac</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; <span class="keywordtype">object</span>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; camera_mat,
<a name="l00984"></a>00984                                <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; dist_coef, <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; rvec, <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; tvec, <span class="keywordtype">bool</span> use_extrinsic_guess=<span class="keyword">false</span>,
<a name="l00985"></a>00985                                <span class="keywordtype">int</span> num_iters=100, <span class="keywordtype">float</span> max_dist=8.0, <span class="keywordtype">int</span> min_inlier_count=100,
<a name="l00986"></a>00986                                std::vector&lt;int&gt;* inliers=NULL);
<a name="l00987"></a>00987 
<a name="l00989"></a>00989 
<a name="l00991"></a>00991 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa9eb3f896ec9b04e57db7fba316650ef" title="performs labeling via graph cuts of a 2D regular 4-connected graph.">graphcut</a>(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; terminals, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; leftTransp, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; rightTransp, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; top, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; bottom, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="namespacecv.html#acd1a236e7d53627b7cb744330f8b59d8">labels</a>,
<a name="l00992"></a>00992                          <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00993"></a>00993 
<a name="l00995"></a>00995 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aa9eb3f896ec9b04e57db7fba316650ef" title="performs labeling via graph cuts of a 2D regular 4-connected graph.">graphcut</a>(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; terminals, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; leftTransp, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; rightTransp, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; top, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; topLeft, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; topRight,
<a name="l00996"></a>00996                          <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; bottom, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; bottomLeft, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; bottomRight,
<a name="l00997"></a>00997                          <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; labels,
<a name="l00998"></a>00998                          <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l00999"></a>00999 
<a name="l01001"></a>01001 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a0d4ec2248d226a50b61a14eb4def99f2" title="compute mask for Generalized Flood fill componetns labeling.">connectivityMask</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a714486ca39ce82afa199836b36993f59">mask</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_scalar__.html">cv::Scalar</a>&amp; lo, <span class="keyword">const</span> <a class="code" href="classcv_1_1_scalar__.html">cv::Scalar</a>&amp; hi, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01002"></a>01002 
<a name="l01004"></a>01004 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a4418321951237ef3f292a8a20b973053" title="performs connected componnents labeling.">labelComponents</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; components, <span class="keywordtype">int</span> flags = 0, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01005"></a>01005 
<a name="l01007"></a>01007 
<a name="l01009"></a>01009 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae731d63fbb0fd3123c11fd7534d8cfcf" title="Compute levels with even distribution. levels will have 1 row and nLevels cols and CV_32SC1 type...">evenLevels</a>(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="tracking_8hpp.html#a1c85c8190b686c9f597e5c1c6cc154a7">levels</a>, <span class="keywordtype">int</span> nLevels, <span class="keywordtype">int</span> lowerLevel, <span class="keywordtype">int</span> upperLevel);
<a name="l01013"></a>01013 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a110be464ef972edd9424c434feeb0115">histEven</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="imgproc__c_8h.html#ab0663c690702cf27bead756ca1afba84">hist</a>, <span class="keywordtype">int</span> histSize, <span class="keywordtype">int</span> lowerLevel, <span class="keywordtype">int</span> upperLevel, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01014"></a>01014 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a110be464ef972edd9424c434feeb0115">histEven</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <span class="keywordtype">int</span> histSize, <span class="keywordtype">int</span> lowerLevel, <span class="keywordtype">int</span> upperLevel, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01019"></a>01019 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a110be464ef972edd9424c434feeb0115">histEven</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> hist[4], <span class="keywordtype">int</span> histSize[4], <span class="keywordtype">int</span> lowerLevel[4], <span class="keywordtype">int</span> upperLevel[4], <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01020"></a>01020 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a110be464ef972edd9424c434feeb0115">histEven</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> hist[4], <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <span class="keywordtype">int</span> histSize[4], <span class="keywordtype">int</span> lowerLevel[4], <span class="keywordtype">int</span> upperLevel[4], <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01025"></a>01025 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a7a4b6fd14789627c9d02405f5ca650ea">histRange</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="tracking_8hpp.html#a1c85c8190b686c9f597e5c1c6cc154a7">levels</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01026"></a>01026 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a7a4b6fd14789627c9d02405f5ca650ea">histRange</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; levels, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01032"></a>01032 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a7a4b6fd14789627c9d02405f5ca650ea">histRange</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> hist[4], <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> levels[4], <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01033"></a>01033 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a7a4b6fd14789627c9d02405f5ca650ea">histRange</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> hist[4], <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> levels[4], <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01034"></a>01034 
<a name="l01037"></a>01037 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#af682126a7dcab8dcc9730d0ab61a1253">calcHist</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01038"></a>01038 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#af682126a7dcab8dcc9730d0ab61a1253">calcHist</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01039"></a>01039 
<a name="l01041"></a>01041 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae6cf6f4fa72af8d992c8b28839037b01" title="normalizes the grayscale image brightness and contrast by normalizing its histogram">equalizeHist</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01042"></a>01042 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae6cf6f4fa72af8d992c8b28839037b01" title="normalizes the grayscale image brightness and contrast by normalizing its histogram">equalizeHist</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01043"></a>01043 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ae6cf6f4fa72af8d992c8b28839037b01" title="normalizes the grayscale image brightness and contrast by normalizing its histogram">equalizeHist</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; hist, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01044"></a>01044 
<a name="l01046"></a>01046 
<a name="l01047"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html">01047</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html">StereoBM_GPU</a>
<a name="l01048"></a>01048 {
<a name="l01049"></a>01049 <span class="keyword">public</span>:
<a name="l01050"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#ac8f0677601a727c0f91eedced6692e88a1ea84e0b03274cb2b6a55b3c8c4e5ee2">01050</a>     <span class="keyword">enum</span> { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };
<a name="l01051"></a>01051 
<a name="l01052"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a660a1e5258f2e319d0a5274f941b08f3af32dfd5296df828cdb74893979fad282">01052</a>     <span class="keyword">enum</span> { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };
<a name="l01053"></a>01053 
<a name="l01055"></a>01055     <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html">StereoBM_GPU</a>();
<a name="l01057"></a>01057     <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html">StereoBM_GPU</a>(<span class="keywordtype">int</span> preset, <span class="keywordtype">int</span> ndisparities = DEFAULT_NDISP, <span class="keywordtype">int</span> winSize = DEFAULT_WINSZ);
<a name="l01058"></a>01058 
<a name="l01061"></a>01061     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; left, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; right, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="calib3d_8hpp.html#acd2ef073a3a4984e0a0ebac5c7e179fd">disparity</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01062"></a>01062 
<a name="l01064"></a>01064     <span class="comment">// if current GPU will be faster than CPU in this algorithm.</span>
<a name="l01065"></a>01065     <span class="comment">// It queries current active device.</span>
<a name="l01066"></a>01066     <span class="keyword">static</span> <span class="keywordtype">bool</span> checkIfGpuCallReasonable();
<a name="l01067"></a>01067 
<a name="l01068"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a82683f26180823d2e8480b1deecff658">01068</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a82683f26180823d2e8480b1deecff658">preset</a>;
<a name="l01069"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#aec33b952759ff2881ae7267598bc8097">01069</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#aec33b952759ff2881ae7267598bc8097">ndisp</a>;
<a name="l01070"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a1d849fcce4681317150454fbd685dbc8">01070</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a1d849fcce4681317150454fbd685dbc8">winSize</a>;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     <span class="comment">// If avergeTexThreshold  == 0 =&gt; post procesing is disabled</span>
<a name="l01073"></a>01073     <span class="comment">// If avergeTexThreshold != 0 then disparity is set 0 in each point (x,y) where for left image</span>
<a name="l01074"></a>01074     <span class="comment">// SumOfHorizontalGradiensInWindow(x, y, winSize) &lt; (winSize * winSize) * avergeTexThreshold</span>
<a name="l01075"></a>01075     <span class="comment">// i.e. input left image is low textured.</span>
<a name="l01076"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a3b57fc867865800b50524725de81cdd4">01076</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_b_m___g_p_u.html#a3b57fc867865800b50524725de81cdd4">avergeTexThreshold</a>;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 <span class="keyword">private</span>:
<a name="l01079"></a>01079     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> minSSD, leBuf, riBuf;
<a name="l01080"></a>01080 };
<a name="l01081"></a>01081 
<a name="l01083"></a>01083 <span class="comment">// &quot;Efficient Belief Propagation for Early Vision&quot;</span>
<a name="l01084"></a>01084 <span class="comment">// P.Felzenszwalb</span>
<a name="l01085"></a>01085 
<a name="l01086"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html">01086</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html">StereoBeliefPropagation</a>
<a name="l01087"></a>01087 {
<a name="l01088"></a>01088 <span class="keyword">public</span>:
<a name="l01089"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a7959ba27f5a1e11c04939cbb401248eeaecfcc3cfb804629964bf3c1b1e43d208">01089</a>     <span class="keyword">enum</span> { DEFAULT_NDISP  = 64 };
<a name="l01090"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a647bfb8a57971c7d8c04c251519a2fe1a82ed1ac88762686b4b120f335c471fc4">01090</a>     <span class="keyword">enum</span> { DEFAULT_ITERS  = 5  };
<a name="l01091"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#addcabe208e4a13d17ca02598e09b2ae8a1768c3b920473c62f5b20668842a8fc7">01091</a>     <span class="keyword">enum</span> { DEFAULT_LEVELS = 5  };
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     <span class="keyword">static</span> <span class="keywordtype">void</span> estimateRecommendedParams(<span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, <span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#adc7b4b8a6ef510e136071efbc9cd9a58">height</a>, <span class="keywordtype">int</span>&amp; ndisp, <span class="keywordtype">int</span>&amp; iters, <span class="keywordtype">int</span>&amp; levels);
<a name="l01094"></a>01094 
<a name="l01096"></a>01096     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html">StereoBeliefPropagation</a>(<span class="keywordtype">int</span> ndisp  = DEFAULT_NDISP,
<a name="l01097"></a>01097                                      <span class="keywordtype">int</span> iters  = DEFAULT_ITERS,
<a name="l01098"></a>01098                                      <span class="keywordtype">int</span> levels = DEFAULT_LEVELS,
<a name="l01099"></a>01099                                      <span class="keywordtype">int</span> msg_type = CV_32F);
<a name="l01100"></a>01100 
<a name="l01107"></a>01107     <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html">StereoBeliefPropagation</a>(<span class="keywordtype">int</span> ndisp, <span class="keywordtype">int</span> iters, <span class="keywordtype">int</span> levels,
<a name="l01108"></a>01108         <span class="keywordtype">float</span> max_data_term, <span class="keywordtype">float</span> data_weight,
<a name="l01109"></a>01109         <span class="keywordtype">float</span> max_disc_term, <span class="keywordtype">float</span> disc_single_jump,
<a name="l01110"></a>01110         <span class="keywordtype">int</span> msg_type = CV_32F);
<a name="l01111"></a>01111 
<a name="l01114"></a>01114     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; left, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; right, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="calib3d_8hpp.html#acd2ef073a3a4984e0a0ebac5c7e179fd">disparity</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 
<a name="l01118"></a>01118     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#acd1647952fba31484ea63d6f1140e509">data</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; disparity, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01119"></a>01119 
<a name="l01120"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a0d731e1e2cfc606e05853ad240339b85">01120</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a0d731e1e2cfc606e05853ad240339b85">ndisp</a>;
<a name="l01121"></a>01121 
<a name="l01122"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a468adfcd6c5453ec3b79b496d404610f">01122</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a468adfcd6c5453ec3b79b496d404610f">iters</a>;
<a name="l01123"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#abf1426daac046c64ff00b02065b15caf">01123</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#abf1426daac046c64ff00b02065b15caf">levels</a>;
<a name="l01124"></a>01124 
<a name="l01125"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a40764d557deb13ec8505fdb59ea9df66">01125</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a40764d557deb13ec8505fdb59ea9df66">max_data_term</a>;
<a name="l01126"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#aa228ac4e9eb3ba78eb3039d972c458b1">01126</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#aa228ac4e9eb3ba78eb3039d972c458b1">data_weight</a>;
<a name="l01127"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#ad6ecab0b3d6ddb925d08fa9030f8bc91">01127</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#ad6ecab0b3d6ddb925d08fa9030f8bc91">max_disc_term</a>;
<a name="l01128"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a87bd96dd0ef5d823fec95a5145685b34">01128</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a87bd96dd0ef5d823fec95a5145685b34">disc_single_jump</a>;
<a name="l01129"></a>01129 
<a name="l01130"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a0a7d82324e2922f8e7e826b26a447ee6">01130</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_belief_propagation.html#a0a7d82324e2922f8e7e826b26a447ee6">msg_type</a>;
<a name="l01131"></a>01131 <span class="keyword">private</span>:
<a name="l01132"></a>01132     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> u, <a class="code" href="legacy_8hpp.html#a6f364afbe132c4ecfea48bde1b0618ba">d</a>, l, <a class="code" href="core__c_8h.html#a54709f3b06b33b66763f1613cc7fb571">r</a>, u2, d2, l2, r2;
<a name="l01133"></a>01133     std::vector&lt;GpuMat&gt; datas;
<a name="l01134"></a>01134     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> out;
<a name="l01135"></a>01135 };
<a name="l01136"></a>01136 
<a name="l01138"></a>01138 <span class="comment">// &quot;A Constant-Space Belief Propagation Algorithm for Stereo Matching&quot;</span>
<a name="l01139"></a>01139 <span class="comment">// Qingxiong Yang, Liang Wang, Narendra Ahuja</span>
<a name="l01140"></a>01140 <span class="comment">// http://vision.ai.uiuc.edu/~qyang6/</span>
<a name="l01141"></a>01141 
<a name="l01142"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html">01142</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html">StereoConstantSpaceBP</a>
<a name="l01143"></a>01143 {
<a name="l01144"></a>01144 <span class="keyword">public</span>:
<a name="l01145"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#abefb30a3e883fdcd56bc6b19afd09cd0a6eb05da7034cd7d04a243a0bb7bf8588">01145</a>     <span class="keyword">enum</span> { DEFAULT_NDISP    = 128 };
<a name="l01146"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a8c0e5a5e7d07817c01c1f728dbee31e7ab9cddd75bf692fe83077b95498a930dd">01146</a>     <span class="keyword">enum</span> { DEFAULT_ITERS    = 8   };
<a name="l01147"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a963b5c9511476df46d24ce134d3feb15adcc1c66dd82e68f97a02244894c932d8">01147</a>     <span class="keyword">enum</span> { DEFAULT_LEVELS   = 4   };
<a name="l01148"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a58bfa125ec6a6cf3d1f5faf12d517835a22afcf495d8900e5bf3eb4d519643ade">01148</a>     <span class="keyword">enum</span> { DEFAULT_NR_PLANE = 4   };
<a name="l01149"></a>01149 
<a name="l01150"></a>01150     <span class="keyword">static</span> <span class="keywordtype">void</span> estimateRecommendedParams(<span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, <span class="keywordtype">int</span> <a class="code" href="highgui__c_8h.html#adc7b4b8a6ef510e136071efbc9cd9a58">height</a>, <span class="keywordtype">int</span>&amp; ndisp, <span class="keywordtype">int</span>&amp; iters, <span class="keywordtype">int</span>&amp; levels, <span class="keywordtype">int</span>&amp; nr_plane);
<a name="l01151"></a>01151 
<a name="l01153"></a>01153     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html">StereoConstantSpaceBP</a>(<span class="keywordtype">int</span> ndisp    = DEFAULT_NDISP,
<a name="l01154"></a>01154                                    <span class="keywordtype">int</span> iters    = DEFAULT_ITERS,
<a name="l01155"></a>01155                                    <span class="keywordtype">int</span> levels   = DEFAULT_LEVELS,
<a name="l01156"></a>01156                                    <span class="keywordtype">int</span> nr_plane = DEFAULT_NR_PLANE,
<a name="l01157"></a>01157                                    <span class="keywordtype">int</span> msg_type = CV_32F);
<a name="l01158"></a>01158 
<a name="l01162"></a>01162     <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html">StereoConstantSpaceBP</a>(<span class="keywordtype">int</span> ndisp, <span class="keywordtype">int</span> iters, <span class="keywordtype">int</span> levels, <span class="keywordtype">int</span> nr_plane,
<a name="l01163"></a>01163         <span class="keywordtype">float</span> max_data_term, <span class="keywordtype">float</span> data_weight, <span class="keywordtype">float</span> max_disc_term, <span class="keywordtype">float</span> disc_single_jump,
<a name="l01164"></a>01164         <span class="keywordtype">int</span> min_disp_th = 0,
<a name="l01165"></a>01165         <span class="keywordtype">int</span> msg_type = CV_32F);
<a name="l01166"></a>01166 
<a name="l01169"></a>01169     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; left, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; right, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; disparity, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01170"></a>01170 
<a name="l01171"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#ad581f8f942bce3c65131ef5db9051dd3">01171</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#ad581f8f942bce3c65131ef5db9051dd3">ndisp</a>;
<a name="l01172"></a>01172 
<a name="l01173"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a259939bb24dd2f1de48e718e9b7d4f5e">01173</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a259939bb24dd2f1de48e718e9b7d4f5e">iters</a>;
<a name="l01174"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a343113cd7fac638c7bbdb0e8854e4416">01174</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a343113cd7fac638c7bbdb0e8854e4416">levels</a>;
<a name="l01175"></a>01175 
<a name="l01176"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a75c85050ba1c024997ff44dcd05593e4">01176</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a75c85050ba1c024997ff44dcd05593e4">nr_plane</a>;
<a name="l01177"></a>01177 
<a name="l01178"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a57d8b29ef9d9f496fdcfdbb82f27b2e9">01178</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a57d8b29ef9d9f496fdcfdbb82f27b2e9">max_data_term</a>;
<a name="l01179"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#aa6a65a63755315c42fc9f3db17c04fc7">01179</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#aa6a65a63755315c42fc9f3db17c04fc7">data_weight</a>;
<a name="l01180"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#af39f878f966eace5a27b54ae518b17ec">01180</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#af39f878f966eace5a27b54ae518b17ec">max_disc_term</a>;
<a name="l01181"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a98d239cda5f01d67be1086318f8a37ce">01181</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#a98d239cda5f01d67be1086318f8a37ce">disc_single_jump</a>;
<a name="l01182"></a>01182 
<a name="l01183"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#ada95c36baf3e7f59ecbadcb34ef3f609">01183</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#ada95c36baf3e7f59ecbadcb34ef3f609">min_disp_th</a>;
<a name="l01184"></a>01184 
<a name="l01185"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#aeba70bf4f20c6e7cbcaae764d7c30b24">01185</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#aeba70bf4f20c6e7cbcaae764d7c30b24">msg_type</a>;
<a name="l01186"></a>01186 
<a name="l01187"></a><a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#adb71b7b7cdc36ff4ee1535dc0abd4d73">01187</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_stereo_constant_space_b_p.html#adb71b7b7cdc36ff4ee1535dc0abd4d73">use_local_init_data_cost</a>;
<a name="l01188"></a>01188 <span class="keyword">private</span>:
<a name="l01189"></a>01189     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> messages_buffers;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="imgproc__c_8h.html#afe009251fa48e9266e8b38c63b7b8003">temp</a>;
<a name="l01192"></a>01192     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> out;
<a name="l01193"></a>01193 };
<a name="l01194"></a>01194 
<a name="l01196"></a>01196 <span class="comment">// Disparity map refinement using joint bilateral filtering given a single color image.</span>
<a name="l01197"></a>01197 <span class="comment">// Qingxiong Yang, Liang Wang, Narendra Ahuja</span>
<a name="l01198"></a>01198 <span class="comment">// http://vision.ai.uiuc.edu/~qyang6/</span>
<a name="l01199"></a>01199 
<a name="l01200"></a><a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html">01200</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html">DisparityBilateralFilter</a>
<a name="l01201"></a>01201 {
<a name="l01202"></a>01202 <span class="keyword">public</span>:
<a name="l01203"></a><a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html#aaf4de20ef10c17ddfb4fbfec88b18880af836d97561d11485f55798919244662d">01203</a>     <span class="keyword">enum</span> { DEFAULT_NDISP  = 64 };
<a name="l01204"></a><a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html#a518afd1eaf5b49a398dee790cfa3d379a4d67e68ea06c6e8c17538039d92371b2">01204</a>     <span class="keyword">enum</span> { DEFAULT_RADIUS = 3 };
<a name="l01205"></a><a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html#a7d282389b59b8c93dd5ad796aacdaa2ca86aa9f9a5e2905c7adc57c6d479f91d9">01205</a>     <span class="keyword">enum</span> { DEFAULT_ITERS  = 1 };
<a name="l01206"></a>01206 
<a name="l01208"></a>01208     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html">DisparityBilateralFilter</a>(<span class="keywordtype">int</span> ndisp = DEFAULT_NDISP, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a7bea932e1cd0c79d103a7870a1921a4e">radius</a> = DEFAULT_RADIUS, <span class="keywordtype">int</span> iters = DEFAULT_ITERS);
<a name="l01209"></a>01209 
<a name="l01213"></a>01213     <a class="code" href="classcv_1_1gpu_1_1_disparity_bilateral_filter.html">DisparityBilateralFilter</a>(<span class="keywordtype">int</span> ndisp, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a7bea932e1cd0c79d103a7870a1921a4e">radius</a>, <span class="keywordtype">int</span> iters, <span class="keywordtype">float</span> edge_threshold, <span class="keywordtype">float</span> max_disc_threshold, <span class="keywordtype">float</span> sigma_range);
<a name="l01214"></a>01214 
<a name="l01217"></a>01217     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; disparity, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dst, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01218"></a>01218 
<a name="l01219"></a>01219 <span class="keyword">private</span>:
<a name="l01220"></a>01220     <span class="keywordtype">int</span> ndisp;
<a name="l01221"></a>01221     <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a7bea932e1cd0c79d103a7870a1921a4e">radius</a>;
<a name="l01222"></a>01222     <span class="keywordtype">int</span> iters;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="keywordtype">float</span> edge_threshold;
<a name="l01225"></a>01225     <span class="keywordtype">float</span> max_disc_threshold;
<a name="l01226"></a>01226     <span class="keywordtype">float</span> sigma_range;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> table_color;
<a name="l01229"></a>01229     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> table_space;
<a name="l01230"></a>01230 };
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 
<a name="l01234"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html">01234</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html">HOGConfidence</a>
<a name="l01235"></a>01235 {
<a name="l01236"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#af738aabee1627811b755e2684c469f0d">01236</a>    <span class="keywordtype">double</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#af738aabee1627811b755e2684c469f0d">scale</a>;
<a name="l01237"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#abc89125e427cdf2acd7d15643abbf302">01237</a>    vector&lt;Point&gt; <a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#abc89125e427cdf2acd7d15643abbf302">locations</a>;
<a name="l01238"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#a826ac3c9eb800b4dd0efe393e29262d6">01238</a>    vector&lt;double&gt; <a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#a826ac3c9eb800b4dd0efe393e29262d6">confidences</a>;
<a name="l01239"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_confidence.html#acc690e495cab679ba15a6fa1ab95d142">01239</a>    vector&lt;double&gt; part_scores[4];
<a name="l01240"></a>01240 };
<a name="l01241"></a>01241 
<a name="l01242"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html">01242</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html">HOGDescriptor</a>
<a name="l01243"></a>01243 {
<a name="l01244"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#af540505cd9254195a36d4f8082c05d9ea833f2a58ab55cf7a2cb49366d64d066b">01244</a>     <span class="keyword">enum</span> { DEFAULT_WIN_SIGMA = -1 };
<a name="l01245"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a11d840e6aa7db0b2240e945d71addb7fae00e31f310c33d88c6b1fe11f6146b16">01245</a>     <span class="keyword">enum</span> { DEFAULT_NLEVELS = 64 };
<a name="l01246"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a62937d47012525f38f55a2bbc0c95e86ad73e5878268db334a78ec62d779f5d7d">01246</a>     <span class="keyword">enum</span> { <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a62937d47012525f38f55a2bbc0c95e86ad73e5878268db334a78ec62d779f5d7d">DESCR_FORMAT_ROW_BY_ROW</a>, DESCR_FORMAT_COL_BY_COL };
<a name="l01247"></a>01247 
<a name="l01248"></a>01248     <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html">HOGDescriptor</a>(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="legacy_8hpp.html#a288228f7d1b8c11df847057580afc5b2">win_size</a>=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(64, 128), <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="imgproc__c_8h.html#a2d7c85a0cd4aeceb7043475ac38fe836">block_size</a>=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(16, 16),
<a name="l01249"></a>01249                   <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> block_stride=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(8, 8), <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> cell_size=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(8, 8),
<a name="l01250"></a>01250                   <span class="keywordtype">int</span> nbins=9, <span class="keywordtype">double</span> win_sigma=DEFAULT_WIN_SIGMA,
<a name="l01251"></a>01251                   <span class="keywordtype">double</span> threshold_L2hys=0.2, <span class="keywordtype">bool</span> gamma_correction=<span class="keyword">true</span>,
<a name="l01252"></a>01252                   <span class="keywordtype">int</span> nlevels=DEFAULT_NLEVELS);
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="keywordtype">size_t</span> getDescriptorSize() <span class="keyword">const</span>;
<a name="l01255"></a>01255     <span class="keywordtype">size_t</span> getBlockHistogramSize() <span class="keyword">const</span>;
<a name="l01256"></a>01256 
<a name="l01257"></a>01257     <span class="keywordtype">void</span> setSVMDetector(<span class="keyword">const</span> vector&lt;float&gt;&amp; <a class="code" href="objdetect_8hpp.html#a1cb25e3935dfd0a52f5e4f749a176b0c">detector</a>);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     <span class="keyword">static</span> vector&lt;float&gt; getDefaultPeopleDetector();
<a name="l01260"></a>01260     <span class="keyword">static</span> vector&lt;float&gt; getPeopleDetector48x96();
<a name="l01261"></a>01261     <span class="keyword">static</span> vector&lt;float&gt; getPeopleDetector64x128();
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="keywordtype">void</span> detect(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, vector&lt;Point&gt;&amp; found_locations,
<a name="l01264"></a>01264                 <span class="keywordtype">double</span> hit_threshold=0, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> win_stride=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(),
<a name="l01265"></a>01265                 <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> padding=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>());
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     <span class="keywordtype">void</span> detectMultiScale(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, vector&lt;Rect&gt;&amp; found_locations,
<a name="l01268"></a>01268                           <span class="keywordtype">double</span> hit_threshold=0, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> win_stride=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(),
<a name="l01269"></a>01269                           <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> padding=<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(), <span class="keywordtype">double</span> scale0=1.05,
<a name="l01270"></a>01270                           <span class="keywordtype">int</span> group_threshold=2);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272     <span class="keywordtype">void</span> computeConfidence(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, vector&lt;Point&gt;&amp; hits, <span class="keywordtype">double</span> hit_threshold,
<a name="l01273"></a>01273                                                 <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> win_stride, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> padding, vector&lt;Point&gt;&amp; locations, vector&lt;double&gt;&amp; confidences);
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     <span class="keywordtype">void</span> computeConfidenceMultiScale(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, vector&lt;Rect&gt;&amp; found_locations,
<a name="l01276"></a>01276                                                                     <span class="keywordtype">double</span> hit_threshold, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> win_stride, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> padding,
<a name="l01277"></a>01277                                                                     vector&lt;HOGConfidence&gt; &amp;conf_out, <span class="keywordtype">int</span> group_threshold);
<a name="l01278"></a>01278 
<a name="l01279"></a>01279     <span class="keywordtype">void</span> getDescriptors(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> win_stride,
<a name="l01280"></a>01280                         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>,
<a name="l01281"></a>01281                         <span class="keywordtype">int</span> descr_format=DESCR_FORMAT_COL_BY_COL);
<a name="l01282"></a>01282 
<a name="l01283"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a81c175ea3b25ddf619d5a693c6b011b0">01283</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a81c175ea3b25ddf619d5a693c6b011b0">win_size</a>;
<a name="l01284"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a2ffce0472743334cd00683e3ebf1aee5">01284</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a2ffce0472743334cd00683e3ebf1aee5">block_size</a>;
<a name="l01285"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a64bd53b911a4b5399cf015b409ba1e85">01285</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a64bd53b911a4b5399cf015b409ba1e85">block_stride</a>;
<a name="l01286"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#ae9f565c6b25defa6a52ddabfd61bccb1">01286</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#ae9f565c6b25defa6a52ddabfd61bccb1">cell_size</a>;
<a name="l01287"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a40800ea71ba0552bb8af9189f2c5fdf6">01287</a>     <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a40800ea71ba0552bb8af9189f2c5fdf6">nbins</a>;
<a name="l01288"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a54487b481e329b2dc0d8d018a988b5ff">01288</a>     <span class="keywordtype">double</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a54487b481e329b2dc0d8d018a988b5ff">win_sigma</a>;
<a name="l01289"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a7b1bb51bd628992aa16a775209062def">01289</a>     <span class="keywordtype">double</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a7b1bb51bd628992aa16a775209062def">threshold_L2hys</a>;
<a name="l01290"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#ad98fee76f0f3f497065f38a9a52af09c">01290</a>     <span class="keywordtype">bool</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#ad98fee76f0f3f497065f38a9a52af09c">gamma_correction</a>;
<a name="l01291"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a8d4190de991a722004da4a8e724dffd9">01291</a>     <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a8d4190de991a722004da4a8e724dffd9">nlevels</a>;
<a name="l01292"></a>01292 
<a name="l01293"></a>01293 <span class="keyword">protected</span>:
<a name="l01294"></a>01294     <span class="keywordtype">void</span> computeBlockHistograms(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img);
<a name="l01295"></a>01295     <span class="keywordtype">void</span> computeGradient(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; grad, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; qangle);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="keywordtype">double</span> getWinSigma() <span class="keyword">const</span>;
<a name="l01298"></a>01298     <span class="keywordtype">bool</span> checkDetectorSize() <span class="keyword">const</span>;
<a name="l01299"></a>01299 
<a name="l01300"></a>01300     <span class="keyword">static</span> <span class="keywordtype">int</span> numPartsWithin(<span class="keywordtype">int</span> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>, <span class="keywordtype">int</span> part_size, <span class="keywordtype">int</span> stride);
<a name="l01301"></a>01301     <span class="keyword">static</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> numPartsWithin(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> part_size, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> stride);
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="comment">// Coefficients of the separating plane</span>
<a name="l01304"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a490a998c5bccba208ab0684fdcc1bc2d">01304</a>     <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a490a998c5bccba208ab0684fdcc1bc2d">free_coef</a>;
<a name="l01305"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a4d765f28f1af6854eda44e3406a0b122">01305</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a4d765f28f1af6854eda44e3406a0b122">detector</a>;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     <span class="comment">// Results of the last classification step</span>
<a name="l01308"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#aa09819a63d77f1a819842634d0f894b3">01308</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="namespacecv.html#acd1a236e7d53627b7cb744330f8b59d8">labels</a>, <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#aa09819a63d77f1a819842634d0f894b3">labels_buf</a>;
<a name="l01309"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a83a636e0dddd8480f2eea8f81b9ebcc5">01309</a>     <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a83a636e0dddd8480f2eea8f81b9ebcc5">labels_host</a>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311     <span class="comment">// Results of the last histogram evaluation step</span>
<a name="l01312"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a050f2faf673931e2a6cb1c704497880e">01312</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> block_hists, <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a050f2faf673931e2a6cb1c704497880e">block_hists_buf</a>;
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     <span class="comment">// Gradients conputation results</span>
<a name="l01315"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a23ecc6bada4c3f54dfc4e9d67caaf5ad">01315</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> grad, qangle, grad_buf, <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a23ecc6bada4c3f54dfc4e9d67caaf5ad">qangle_buf</a>;
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="comment">// returns subbuffer with required size, reallocates buffer if nessesary.</span>
<a name="l01318"></a>01318     <span class="keyword">static</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> getBuffer(<span class="keyword">const</span> <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a>&amp; sz, <span class="keywordtype">int</span> type, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l01319"></a>01319     <span class="keyword">static</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> getBuffer(<span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a061459acc9e078fa4699e0e349887215">rows</a>, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a4407a60bc4387adae24cee658711f2d9">cols</a>, <span class="keywordtype">int</span> type, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; buf);
<a name="l01320"></a>01320 
<a name="l01321"></a><a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a2301efeb64505e3cbf63f6f3b5a01bf7">01321</a>     std::vector&lt;GpuMat&gt; <a class="code" href="structcv_1_1gpu_1_1_h_o_g_descriptor.html#a2301efeb64505e3cbf63f6f3b5a01bf7">image_scales</a>;
<a name="l01322"></a>01322 };
<a name="l01323"></a>01323 
<a name="l01324"></a>01324 
<a name="l01326"></a>01326 
<a name="l01327"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">01327</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>
<a name="l01328"></a>01328 {
<a name="l01329"></a>01329 <span class="keyword">public</span>:
<a name="l01330"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html#aed33fcc2dc26fe578648b63d1726b825a3a3b09b7d87b4c338bff7807249a14cd">01330</a>     <span class="keyword">enum</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html#aed33fcc2dc26fe578648b63d1726b825">DistType</a> {L1Dist = 0, <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html#aed33fcc2dc26fe578648b63d1726b825a3a3b09b7d87b4c338bff7807249a14cd">L2Dist</a>, HammingDist};
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(DistType distType = L2Dist);
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     <span class="comment">// Add descriptors to train descriptor collection</span>
<a name="l01335"></a>01335     <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#ad04bf54d4fe4ef08ab013d3054c0322b" title="adds one matrix to another (c = a + b)">add</a>(<span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; descCollection);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     <span class="comment">// Get train descriptors collection</span>
<a name="l01338"></a>01338     <span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; getTrainDescriptors() <span class="keyword">const</span>;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340     <span class="comment">// Clear train descriptors collection</span>
<a name="l01341"></a>01341     <span class="keywordtype">void</span> <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1gl.html#a2fbfcc011e3992ebe4a239464a97d896">clear</a>();
<a name="l01342"></a>01342 
<a name="l01343"></a>01343     <span class="comment">// Return true if there are not train descriptors in collection</span>
<a name="l01344"></a>01344     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346     <span class="comment">// Return true if the matcher supports mask in match methods</span>
<a name="l01347"></a>01347     <span class="keywordtype">bool</span> isMaskSupported() <span class="keyword">const</span>;
<a name="l01348"></a>01348 
<a name="l01349"></a>01349     <span class="comment">// Find one best match for each query descriptor</span>
<a name="l01350"></a>01350     <span class="keywordtype">void</span> matchSingle(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; train,
<a name="l01351"></a>01351         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance,
<a name="l01352"></a>01352         <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01353"></a>01353 
<a name="l01354"></a>01354     <span class="comment">// Download trainIdx and distance and convert it to CPU vector with DMatch</span>
<a name="l01355"></a>01355     <span class="keyword">static</span> <span class="keywordtype">void</span> matchDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, std::vector&lt;DMatch&gt;&amp; matches);
<a name="l01356"></a>01356     <span class="comment">// Convert trainIdx and distance to vector with DMatch</span>
<a name="l01357"></a>01357     <span class="keyword">static</span> <span class="keywordtype">void</span> matchConvert(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; distance, std::vector&lt;DMatch&gt;&amp; matches);
<a name="l01358"></a>01358 
<a name="l01359"></a>01359     <span class="comment">// Find one best match for each query descriptor</span>
<a name="l01360"></a>01360     <span class="keywordtype">void</span> match(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; train, std::vector&lt;DMatch&gt;&amp; matches, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>());
<a name="l01361"></a>01361 
<a name="l01362"></a>01362     <span class="comment">// Make gpu collection of trains and masks in suitable format for matchCollection function</span>
<a name="l01363"></a>01363     <span class="keywordtype">void</span> makeGpuCollection(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainCollection, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; maskCollection, <span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; masks = std::vector&lt;GpuMat&gt;());
<a name="l01364"></a>01364 
<a name="l01365"></a>01365     <span class="comment">// Find one best match from train collection for each query descriptor</span>
<a name="l01366"></a>01366     <span class="keywordtype">void</span> matchCollection(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainCollection,
<a name="l01367"></a>01367         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; imgIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance,
<a name="l01368"></a>01368         <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; masks = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     <span class="comment">// Download trainIdx, imgIdx and distance and convert it to vector with DMatch</span>
<a name="l01371"></a>01371     <span class="keyword">static</span> <span class="keywordtype">void</span> matchDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; imgIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, std::vector&lt;DMatch&gt;&amp; matches);
<a name="l01372"></a>01372     <span class="comment">// Convert trainIdx, imgIdx and distance to vector with DMatch</span>
<a name="l01373"></a>01373     <span class="keyword">static</span> <span class="keywordtype">void</span> matchConvert(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; imgIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; distance, std::vector&lt;DMatch&gt;&amp; matches);
<a name="l01374"></a>01374 
<a name="l01375"></a>01375     <span class="comment">// Find one best match from train collection for each query descriptor.</span>
<a name="l01376"></a>01376     <span class="keywordtype">void</span> match(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, std::vector&lt;DMatch&gt;&amp; matches, <span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; masks = std::vector&lt;GpuMat&gt;());
<a name="l01377"></a>01377 
<a name="l01378"></a>01378     <span class="comment">// Find k best matches for each query descriptor (in increasing order of distances)</span>
<a name="l01379"></a>01379     <span class="keywordtype">void</span> knnMatchSingle(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; train,
<a name="l01380"></a>01380         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; allDist, <span class="keywordtype">int</span> k,
<a name="l01381"></a>01381         <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     <span class="comment">// Download trainIdx and distance and convert it to vector with DMatch</span>
<a name="l01384"></a>01384     <span class="comment">// compactResult is used when mask is not empty. If compactResult is false matches</span>
<a name="l01385"></a>01385     <span class="comment">// vector will have the same size as queryDescriptors rows. If compactResult is true</span>
<a name="l01386"></a>01386     <span class="comment">// matches vector will not contain matches for fully masked out query descriptors.</span>
<a name="l01387"></a>01387     <span class="keyword">static</span> <span class="keywordtype">void</span> knnMatchDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance,
<a name="l01388"></a>01388         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01389"></a>01389     <span class="comment">// Convert trainIdx and distance to vector with DMatch</span>
<a name="l01390"></a>01390     <span class="keyword">static</span> <span class="keywordtype">void</span> knnMatchConvert(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; distance,
<a name="l01391"></a>01391         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01392"></a>01392 
<a name="l01393"></a>01393     <span class="comment">// Find k best matches for each query descriptor (in increasing order of distances).</span>
<a name="l01394"></a>01394     <span class="comment">// compactResult is used when mask is not empty. If compactResult is false matches</span>
<a name="l01395"></a>01395     <span class="comment">// vector will have the same size as queryDescriptors rows. If compactResult is true</span>
<a name="l01396"></a>01396     <span class="comment">// matches vector will not contain matches for fully masked out query descriptors.</span>
<a name="l01397"></a>01397     <span class="keywordtype">void</span> knnMatch(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; train,
<a name="l01398"></a>01398         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">int</span> k, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(),
<a name="l01399"></a>01399         <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401     <span class="comment">// Find k best matches from train collection for each query descriptor (in increasing order of distances)</span>
<a name="l01402"></a>01402     <span class="keywordtype">void</span> knnMatch2Collection(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainCollection,
<a name="l01403"></a>01403         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; imgIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance,
<a name="l01404"></a>01404         <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; maskCollection = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01405"></a>01405 
<a name="l01406"></a>01406     <span class="comment">// Download trainIdx and distance and convert it to vector with DMatch</span>
<a name="l01407"></a>01407     <span class="comment">// compactResult is used when mask is not empty. If compactResult is false matches</span>
<a name="l01408"></a>01408     <span class="comment">// vector will have the same size as queryDescriptors rows. If compactResult is true</span>
<a name="l01409"></a>01409     <span class="comment">// matches vector will not contain matches for fully masked out query descriptors.</span>
<a name="l01410"></a>01410     <span class="keyword">static</span> <span class="keywordtype">void</span> knnMatch2Download(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; imgIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance,
<a name="l01411"></a>01411         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01412"></a>01412     <span class="comment">// Convert trainIdx and distance to vector with DMatch</span>
<a name="l01413"></a>01413     <span class="keyword">static</span> <span class="keywordtype">void</span> knnMatch2Convert(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; imgIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; distance,
<a name="l01414"></a>01414         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01415"></a>01415 
<a name="l01416"></a>01416     <span class="comment">// Find k best matches  for each query descriptor (in increasing order of distances).</span>
<a name="l01417"></a>01417     <span class="comment">// compactResult is used when mask is not empty. If compactResult is false matches</span>
<a name="l01418"></a>01418     <span class="comment">// vector will have the same size as queryDescriptors rows. If compactResult is true</span>
<a name="l01419"></a>01419     <span class="comment">// matches vector will not contain matches for fully masked out query descriptors.</span>
<a name="l01420"></a>01420     <span class="keywordtype">void</span> knnMatch(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">int</span> k,
<a name="l01421"></a>01421         <span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; masks = std::vector&lt;GpuMat&gt;(), <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     <span class="comment">// Find best matches for each query descriptor which have distance less than maxDistance.</span>
<a name="l01424"></a>01424     <span class="comment">// nMatches.at&lt;int&gt;(0, queryIdx) will contain matches count for queryIdx.</span>
<a name="l01425"></a>01425     <span class="comment">// carefully nMatches can be greater than trainIdx.cols - it means that matcher didn&#39;t find all matches,</span>
<a name="l01426"></a>01426     <span class="comment">// because it didn&#39;t have enough memory.</span>
<a name="l01427"></a>01427     <span class="comment">// If trainIdx is empty, then trainIdx and distance will be created with size nQuery x max((nTrain / 100), 10),</span>
<a name="l01428"></a>01428     <span class="comment">// otherwize user can pass own allocated trainIdx and distance with size nQuery x nMaxMatches</span>
<a name="l01429"></a>01429     <span class="comment">// Matches doesn&#39;t sorted.</span>
<a name="l01430"></a>01430     <span class="keywordtype">void</span> radiusMatchSingle(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; train,
<a name="l01431"></a>01431         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nMatches, <span class="keywordtype">float</span> maxDistance,
<a name="l01432"></a>01432         <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01433"></a>01433 
<a name="l01434"></a>01434     <span class="comment">// Download trainIdx, nMatches and distance and convert it to vector with DMatch.</span>
<a name="l01435"></a>01435     <span class="comment">// matches will be sorted in increasing order of distances.</span>
<a name="l01436"></a>01436     <span class="comment">// compactResult is used when mask is not empty. If compactResult is false matches</span>
<a name="l01437"></a>01437     <span class="comment">// vector will have the same size as queryDescriptors rows. If compactResult is true</span>
<a name="l01438"></a>01438     <span class="comment">// matches vector will not contain matches for fully masked out query descriptors.</span>
<a name="l01439"></a>01439     <span class="keyword">static</span> <span class="keywordtype">void</span> radiusMatchDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nMatches,
<a name="l01440"></a>01440         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01441"></a>01441     <span class="comment">// Convert trainIdx, nMatches and distance to vector with DMatch.</span>
<a name="l01442"></a>01442     <span class="keyword">static</span> <span class="keywordtype">void</span> radiusMatchConvert(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; distance, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; nMatches,
<a name="l01443"></a>01443         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     <span class="comment">// Find best matches for each query descriptor which have distance less than maxDistance</span>
<a name="l01446"></a>01446     <span class="comment">// in increasing order of distances).</span>
<a name="l01447"></a>01447     <span class="keywordtype">void</span> radiusMatch(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; train,
<a name="l01448"></a>01448         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">float</span> maxDistance,
<a name="l01449"></a>01449         <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>(), <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     <span class="comment">// Find best matches for each query descriptor which have distance less than maxDistance.</span>
<a name="l01452"></a>01452     <span class="comment">// If trainIdx is empty, then trainIdx and distance will be created with size nQuery x max((nQuery / 100), 10),</span>
<a name="l01453"></a>01453     <span class="comment">// otherwize user can pass own allocated trainIdx and distance with size nQuery x nMaxMatches</span>
<a name="l01454"></a>01454     <span class="comment">// Matches doesn&#39;t sorted.</span>
<a name="l01455"></a>01455     <span class="keywordtype">void</span> radiusMatchCollection(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; imgIdx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nMatches, <span class="keywordtype">float</span> maxDistance,
<a name="l01456"></a>01456         <span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; masks = std::vector&lt;GpuMat&gt;(), <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01457"></a>01457 
<a name="l01458"></a>01458     <span class="comment">// Download trainIdx, imgIdx, nMatches and distance and convert it to vector with DMatch.</span>
<a name="l01459"></a>01459     <span class="comment">// matches will be sorted in increasing order of distances.</span>
<a name="l01460"></a>01460     <span class="comment">// compactResult is used when mask is not empty. If compactResult is false matches</span>
<a name="l01461"></a>01461     <span class="comment">// vector will have the same size as queryDescriptors rows. If compactResult is true</span>
<a name="l01462"></a>01462     <span class="comment">// matches vector will not contain matches for fully masked out query descriptors.</span>
<a name="l01463"></a>01463     <span class="keyword">static</span> <span class="keywordtype">void</span> radiusMatchDownload(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; imgIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; distance, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nMatches,
<a name="l01464"></a>01464         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01465"></a>01465     <span class="comment">// Convert trainIdx, nMatches and distance to vector with DMatch.</span>
<a name="l01466"></a>01466     <span class="keyword">static</span> <span class="keywordtype">void</span> radiusMatchConvert(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; trainIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; imgIdx, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; distance, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; nMatches,
<a name="l01467"></a>01467         std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     <span class="comment">// Find best matches from train collection for each query descriptor which have distance less than</span>
<a name="l01470"></a>01470     <span class="comment">// maxDistance (in increasing order of distances).</span>
<a name="l01471"></a>01471     <span class="keywordtype">void</span> radiusMatch(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; query, std::vector&lt; std::vector&lt;DMatch&gt; &gt;&amp; matches, <span class="keywordtype">float</span> maxDistance,
<a name="l01472"></a>01472         <span class="keyword">const</span> std::vector&lt;GpuMat&gt;&amp; masks = std::vector&lt;GpuMat&gt;(), <span class="keywordtype">bool</span> compactResult = <span class="keyword">false</span>);
<a name="l01473"></a>01473 
<a name="l01474"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html#ab7c62ac82124e7910cd3f8529053ecdb">01474</a>     <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html#aed33fcc2dc26fe578648b63d1726b825">DistType</a> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html#ab7c62ac82124e7910cd3f8529053ecdb">distType</a>;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 <span class="keyword">private</span>:
<a name="l01477"></a>01477     std::vector&lt;GpuMat&gt; trainDescCollection;
<a name="l01478"></a>01478 };
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Distance&gt;
<a name="l01481"></a><a class="code" href="namespacecv_1_1gpu.html#a18cc2679ccde492cd45efbc0b7b85fc0">01481</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="namespacecv_1_1gpu.html#a18cc2679ccde492cd45efbc0b7b85fc0">BruteForceMatcher_GPU</a>;
<a name="l01482"></a>01482 
<a name="l01483"></a>01483 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01484"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l1_3_01_t_01_4_01_4.html">01484</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="namespacecv_1_1gpu.html#a18cc2679ccde492cd45efbc0b7b85fc0">BruteForceMatcher_GPU</a>&lt; <a class="code" href="structcv_1_1_l1.html">L1</a>&lt;T&gt; &gt; : <span class="keyword">public</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>
<a name="l01485"></a>01485 {
<a name="l01486"></a>01486 <span class="keyword">public</span>:
<a name="l01487"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l1_3_01_t_01_4_01_4.html#ac74716db9af9644b21b39db9b0949835">01487</a>     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l1_3_01_t_01_4_01_4.html#ac74716db9af9644b21b39db9b0949835">BruteForceMatcher_GPU</a>() : <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(L1Dist) {}
<a name="l01488"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l1_3_01_t_01_4_01_4.html#a1c185e92023f43091a80cd8387ba2ad9">01488</a>     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l1_3_01_t_01_4_01_4.html#a1c185e92023f43091a80cd8387ba2ad9">BruteForceMatcher_GPU</a>(<a class="code" href="structcv_1_1_l1.html">L1&lt;T&gt;</a> <span class="comment">/*d*/</span>) : <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(L1Dist) {}
<a name="l01489"></a>01489 };
<a name="l01490"></a>01490 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01491"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l2_3_01_t_01_4_01_4.html">01491</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="namespacecv_1_1gpu.html#a18cc2679ccde492cd45efbc0b7b85fc0">BruteForceMatcher_GPU</a>&lt; <a class="code" href="structcv_1_1_l2.html">L2</a>&lt;T&gt; &gt; : <span class="keyword">public</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>
<a name="l01492"></a>01492 {
<a name="l01493"></a>01493 <span class="keyword">public</span>:
<a name="l01494"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l2_3_01_t_01_4_01_4.html#a75d21d90f02917dd3030a416a32c8990">01494</a>     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l2_3_01_t_01_4_01_4.html#a75d21d90f02917dd3030a416a32c8990">BruteForceMatcher_GPU</a>() : <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(L2Dist) {}
<a name="l01495"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l2_3_01_t_01_4_01_4.html#a235f1d531935cf38e91f203ee1c11dbc">01495</a>     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_l2_3_01_t_01_4_01_4.html#a235f1d531935cf38e91f203ee1c11dbc">BruteForceMatcher_GPU</a>(<a class="code" href="structcv_1_1_l2.html">L2&lt;T&gt;</a> <span class="comment">/*d*/</span>) : <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(L2Dist) {}
<a name="l01496"></a>01496 };
<a name="l01497"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_hamming_01_4.html">01497</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">class </span>CV_EXPORTS <a class="code" href="namespacecv_1_1gpu.html#a18cc2679ccde492cd45efbc0b7b85fc0">BruteForceMatcher_GPU</a>&lt; <a class="code" href="structcv_1_1_hamming.html">Hamming</a> &gt; : <span class="keyword">public</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>
<a name="l01498"></a>01498 {
<a name="l01499"></a>01499 <span class="keyword">public</span>:
<a name="l01500"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_hamming_01_4.html#a50f6aba558bf3062055a4a4afadc01f9">01500</a>     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_hamming_01_4.html#a50f6aba558bf3062055a4a4afadc01f9">BruteForceMatcher_GPU</a>() : <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(HammingDist) {}
<a name="l01501"></a><a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_hamming_01_4.html#a2a1ef8dabae13e33be6869ece39f7125">01501</a>     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u_3_01_hamming_01_4.html#a2a1ef8dabae13e33be6869ece39f7125">BruteForceMatcher_GPU</a>(<a class="code" href="structcv_1_1_hamming.html">Hamming</a> <span class="comment">/*d*/</span>) : <a class="code" href="classcv_1_1gpu_1_1_brute_force_matcher___g_p_u__base.html">BruteForceMatcher_GPU_base</a>(HammingDist) {}
<a name="l01502"></a>01502 };
<a name="l01503"></a>01503 
<a name="l01505"></a>01505 <span class="comment">// The cascade classifier class for object detection: supports old haar and new lbp xlm formats and nvbin for haar cascades olny.</span>
<a name="l01506"></a><a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html">01506</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html">CascadeClassifier_GPU</a>
<a name="l01507"></a>01507 {
<a name="l01508"></a>01508 <span class="keyword">public</span>:
<a name="l01509"></a>01509     <a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html">CascadeClassifier_GPU</a>();
<a name="l01510"></a>01510     <a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html">CascadeClassifier_GPU</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; <a class="code" href="core__c_8h.html#acc427f35f3bd9f865d39012657cc42f8">filename</a>);
<a name="l01511"></a>01511     ~<a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html">CascadeClassifier_GPU</a>();
<a name="l01512"></a>01512 
<a name="l01513"></a>01513     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
<a name="l01514"></a>01514     <span class="keywordtype">bool</span> <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1audio.html#a71a6f579c46fcbee416f53d492659913">load</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; filename);
<a name="l01515"></a>01515     <span class="keywordtype">void</span> release();
<a name="l01516"></a>01516 
<a name="l01517"></a>01517     <span class="comment">/* returns number of detected objects */</span>
<a name="l01518"></a>01518     <span class="keywordtype">int</span> detectMultiScale(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; objectsBuf, <span class="keywordtype">double</span> scaleFactor = 1.1, <span class="keywordtype">int</span> minNeighbors = 4, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> minSize = <a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>());
<a name="l01519"></a>01519 
<a name="l01520"></a><a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html#ae2278404d7669cd4e98598791d6aac2d">01520</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html#ae2278404d7669cd4e98598791d6aac2d">findLargestObject</a>;
<a name="l01521"></a><a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html#a46c3e4aacca43b5abe7fb048cb08c8f7">01521</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html#a46c3e4aacca43b5abe7fb048cb08c8f7">visualizeInPlace</a>;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> getClassifierSize() <span class="keyword">const</span>;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525 <span class="keyword">private</span>:
<a name="l01526"></a>01526 
<a name="l01527"></a>01527     <span class="keyword">struct </span>CascadeClassifierImpl;
<a name="l01528"></a>01528     CascadeClassifierImpl* impl;
<a name="l01529"></a>01529     <span class="keyword">struct </span>HaarCascade;
<a name="l01530"></a><a class="code" href="classcv_1_1gpu_1_1_cascade_classifier___g_p_u.html#ae58dceeb75c1ee30c78466f3cf43114e">01530</a>     <span class="keyword">struct </span>LbpCascade;
<a name="l01531"></a>01531     <span class="keyword">friend</span> <span class="keyword">class </span>CascadeClassifier_GPU_LBP;
<a name="l01532"></a>01532 };
<a name="l01533"></a>01533 
<a name="l01535"></a>01535 
<a name="l01536"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html">01536</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html">SURF_GPU</a>
<a name="l01537"></a>01537 {
<a name="l01538"></a>01538 <span class="keyword">public</span>:
<a name="l01539"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6e">01539</a>     <span class="keyword">enum</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6e">KeypointLayout</a>
<a name="l01540"></a>01540     {
<a name="l01541"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea716b1dd0c462b9d374d229512ae5a0e8">01541</a>         X_ROW = 0,
<a name="l01542"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea35864a9762ff356b0d7e9a6540c6de48">01542</a>         <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea35864a9762ff356b0d7e9a6540c6de48">Y_ROW</a>,
<a name="l01543"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea1a32c1203199d7f1670be13d6524ec8f">01543</a>         <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea1a32c1203199d7f1670be13d6524ec8f">LAPLACIAN_ROW</a>,
<a name="l01544"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea1622de7d826e5a170716dd390404f8d6">01544</a>         <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea1622de7d826e5a170716dd390404f8d6">OCTAVE_ROW</a>,
<a name="l01545"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea866bb70f621b01a1416b2cf531166234">01545</a>         <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea866bb70f621b01a1416b2cf531166234">SIZE_ROW</a>,
<a name="l01546"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6eaa02773d2a0190e21795245f1bbfa9d8b">01546</a>         <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6eaa02773d2a0190e21795245f1bbfa9d8b">ANGLE_ROW</a>,
<a name="l01547"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea396775f7cb6eaabeae906ba9f5747873">01547</a>         <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6ea396775f7cb6eaabeae906ba9f5747873">HESSIAN_ROW</a>,
<a name="l01548"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#ad6a8dc93808e77e18f2f8100194f8f6eaa88a8bd3c10d64daa41034d0ede3e301">01548</a>         ROWS_COUNT
<a name="l01549"></a>01549     };
<a name="l01550"></a>01550 
<a name="l01552"></a>01552     <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html">SURF_GPU</a>();
<a name="l01554"></a>01554     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html">SURF_GPU</a>(<span class="keywordtype">double</span> _hessianThreshold, <span class="keywordtype">int</span> _nOctaves=4,
<a name="l01555"></a>01555          <span class="keywordtype">int</span> _nOctaveLayers=2, <span class="keywordtype">bool</span> _extended=<span class="keyword">false</span>, <span class="keywordtype">float</span> _keypointsRatio=0.01f, <span class="keywordtype">bool</span> _upright = <span class="keyword">false</span>);
<a name="l01556"></a>01556 
<a name="l01558"></a>01558     <span class="keywordtype">int</span> descriptorSize() <span class="keyword">const</span>;
<a name="l01559"></a>01559 
<a name="l01561"></a>01561     <span class="keywordtype">void</span> uploadKeypoints(<span class="keyword">const</span> vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; keypointsGPU);
<a name="l01563"></a>01563     <span class="keywordtype">void</span> downloadKeypoints(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; keypointsGPU, vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01564"></a>01564 
<a name="l01566"></a>01566     <span class="keywordtype">void</span> downloadDescriptors(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; descriptorsGPU, vector&lt;float&gt;&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>);
<a name="l01567"></a>01567 
<a name="l01578"></a>01578     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01581"></a>01581     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>,
<a name="l01582"></a>01582         <span class="keywordtype">bool</span> useProvidedKeypoints = <span class="keyword">false</span>);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01585"></a>01585     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>,
<a name="l01586"></a>01586         <span class="keywordtype">bool</span> useProvidedKeypoints = <span class="keyword">false</span>);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>, std::vector&lt;float&gt;&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>,
<a name="l01589"></a>01589         <span class="keywordtype">bool</span> useProvidedKeypoints = <span class="keyword">false</span>);
<a name="l01590"></a>01590 
<a name="l01591"></a>01591     <span class="keywordtype">void</span> releaseMemory();
<a name="l01592"></a>01592 
<a name="l01593"></a>01593     <span class="comment">// SURF parameters</span>
<a name="l01594"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a53025850ba797d7881d2a4f404d59bde">01594</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a53025850ba797d7881d2a4f404d59bde">hessianThreshold</a>;
<a name="l01595"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a6a7a8a24cbbf10fca70cd321ce8e395e">01595</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a6a7a8a24cbbf10fca70cd321ce8e395e">nOctaves</a>;
<a name="l01596"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a2d6e1a5ab35c29b30122556e7b6918ac">01596</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a2d6e1a5ab35c29b30122556e7b6918ac">nOctaveLayers</a>;
<a name="l01597"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#acdb52ebab821165cfa57b73b5bd1c218">01597</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#acdb52ebab821165cfa57b73b5bd1c218">extended</a>;
<a name="l01598"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#afcbbc355e0713e4b4124d786f97fb332">01598</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#afcbbc355e0713e4b4124d786f97fb332">upright</a>;
<a name="l01599"></a>01599 
<a name="l01601"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a86a74a2324e38acf3c2324ef0e6a5b0c">01601</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a86a74a2324e38acf3c2324ef0e6a5b0c" title="max keypoints = min(keypointsRatio * img.size().area(), 65535)">keypointsRatio</a>;
<a name="l01602"></a>01602 
<a name="l01603"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a4951aeaa563fb654ddd564ab89e81dfd">01603</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a4951aeaa563fb654ddd564ab89e81dfd">sum</a>, mask1, maskSum, intBuffer;
<a name="l01604"></a>01604 
<a name="l01605"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a9b53bf339ed46f3c3a969217e7950400">01605</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> det, <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a9b53bf339ed46f3c3a969217e7950400">trace</a>;
<a name="l01606"></a>01606 
<a name="l01607"></a><a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a2bbf9d37101f1b4e39f4afe492af40c4">01607</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="classcv_1_1gpu_1_1_s_u_r_f___g_p_u.html#a2bbf9d37101f1b4e39f4afe492af40c4">maxPosBuffer</a>;
<a name="l01608"></a>01608 };
<a name="l01609"></a>01609 
<a name="l01611"></a>01611 
<a name="l01612"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html">01612</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html">FAST_GPU</a>
<a name="l01613"></a>01613 {
<a name="l01614"></a>01614 <span class="keyword">public</span>:
<a name="l01615"></a>01615     <span class="keyword">enum</span>
<a name="l01616"></a>01616     {
<a name="l01617"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a9ae140f844f055e38aa76d334b177a63aa7d22ccbcd65a72e7c981c92515293f9">01617</a>         LOCATION_ROW = 0,
<a name="l01618"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a9ae140f844f055e38aa76d334b177a63a2df36c0c99dfc29326822c3739eac1d0">01618</a>         <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a9ae140f844f055e38aa76d334b177a63a2df36c0c99dfc29326822c3739eac1d0">RESPONSE_ROW</a>,
<a name="l01619"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a9ae140f844f055e38aa76d334b177a63a07c32b647113fa5892988c7b27d188df">01619</a>         ROWS_COUNT
<a name="l01620"></a>01620     };
<a name="l01621"></a>01621 
<a name="l01622"></a>01622     <span class="comment">// all features have same size</span>
<a name="l01623"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#ae2e204176ed9664ca078b5bd1891176f">01623</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> FEATURE_SIZE = 7;
<a name="l01624"></a>01624 
<a name="l01625"></a>01625     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html">FAST_GPU</a>(<span class="keywordtype">int</span> <a class="code" href="namespacecv_1_1gpu.html#a63944c7054df081596be6b4cf94df871" title="applies fixed threshold to the image">threshold</a>, <span class="keywordtype">bool</span> nonmaxSupression = <span class="keyword">true</span>, <span class="keywordtype">double</span> keypointsRatio = 0.05);
<a name="l01626"></a>01626 
<a name="l01629"></a>01629     <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01630"></a>01630     <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01631"></a>01631 
<a name="l01633"></a>01633     <span class="keywordtype">void</span> downloadKeypoints(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; d_keypoints, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01634"></a>01634 
<a name="l01636"></a>01636     <span class="keywordtype">void</span> convertKeypoints(<span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; h_keypoints, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01637"></a>01637 
<a name="l01639"></a>01639     <span class="keywordtype">void</span> release();
<a name="l01640"></a>01640 
<a name="l01641"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a73b328bc50cd60cec18f85bea59dff1c">01641</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a73b328bc50cd60cec18f85bea59dff1c">nonmaxSupression</a>;
<a name="l01642"></a>01642 
<a name="l01643"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a28b49bef52f11f2c366bf9167c52d985">01643</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a28b49bef52f11f2c366bf9167c52d985">threshold</a>;
<a name="l01644"></a>01644 
<a name="l01646"></a><a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a82f6122d0207b098068279d6fd75b973">01646</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html#a82f6122d0207b098068279d6fd75b973" title="max keypoints = keypointsRatio * img.size().area()">keypointsRatio</a>;
<a name="l01647"></a>01647 
<a name="l01650"></a>01650     <span class="keywordtype">int</span> calcKeyPointsLocation(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask);
<a name="l01651"></a>01651 
<a name="l01655"></a>01655     <span class="keywordtype">int</span> getKeyPoints(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01656"></a>01656 
<a name="l01657"></a>01657 <span class="keyword">private</span>:
<a name="l01658"></a>01658     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> kpLoc_;
<a name="l01659"></a>01659     <span class="keywordtype">int</span> count_;
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> score_;
<a name="l01662"></a>01662 
<a name="l01663"></a>01663     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> d_keypoints_;
<a name="l01664"></a>01664 };
<a name="l01665"></a>01665 
<a name="l01667"></a>01667 
<a name="l01668"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html">01668</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html">ORB_GPU</a>
<a name="l01669"></a>01669 {
<a name="l01670"></a>01670 <span class="keyword">public</span>:
<a name="l01671"></a>01671     <span class="keyword">enum</span>
<a name="l01672"></a>01672     {
<a name="l01673"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a5767e52ed0ad47c2520836685b9d4c87">01673</a>         X_ROW = 0,
<a name="l01674"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a9d6a4b4b49a366b7b6f39c6ff1ac0ea2">01674</a>         <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a9d6a4b4b49a366b7b6f39c6ff1ac0ea2">Y_ROW</a>,
<a name="l01675"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a2596162c2cf8cabddb89cb71a779d9c3">01675</a>         <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a2596162c2cf8cabddb89cb71a779d9c3">RESPONSE_ROW</a>,
<a name="l01676"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a305d62b7a90a319886a897e3c83e193b">01676</a>         <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a305d62b7a90a319886a897e3c83e193b">ANGLE_ROW</a>,
<a name="l01677"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a9d1d2f66bf10b01e230057d699772578">01677</a>         <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43a9d1d2f66bf10b01e230057d699772578">OCTAVE_ROW</a>,
<a name="l01678"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43ab8d375a2903dc6c3d42952c2e25ccc3b">01678</a>         <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43ab8d375a2903dc6c3d42952c2e25ccc3b">SIZE_ROW</a>,
<a name="l01679"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#aaac44e452ce1d6e2dad9aed45200ad43ab6cc058f5a6e1b7e366acd60a4d5b21b">01679</a>         ROWS_COUNT
<a name="l01680"></a>01680     };
<a name="l01681"></a>01681 
<a name="l01682"></a>01682     <span class="keyword">enum</span>
<a name="l01683"></a>01683     {
<a name="l01684"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#af0c58a36c1b6677b734931c36063c5a8a0c68b74ed44e64fbee00c13a0c61861e">01684</a>         DEFAULT_FAST_THRESHOLD = 20
<a name="l01685"></a>01685     };
<a name="l01686"></a>01686 
<a name="l01688"></a>01688     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html">ORB_GPU</a>(<span class="keywordtype">int</span> nFeatures = 500, <span class="keywordtype">float</span> scaleFactor = 1.2f, <span class="keywordtype">int</span> nLevels = 8, <span class="keywordtype">int</span> edgeThreshold = 31,
<a name="l01689"></a>01689                      <span class="keywordtype">int</span> firstLevel = 0, <span class="keywordtype">int</span> WTA_K = 2, <span class="keywordtype">int</span> scoreType = 0, <span class="keywordtype">int</span> patchSize = 31);
<a name="l01690"></a>01690 
<a name="l01695"></a>01695     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01696"></a>01696     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01697"></a>01697 
<a name="l01703"></a>01703     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>);
<a name="l01704"></a>01704     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>);
<a name="l01705"></a>01705 
<a name="l01707"></a>01707     <span class="keywordtype">void</span> downloadKeyPoints(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; d_keypoints, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01708"></a>01708 
<a name="l01710"></a>01710     <span class="keywordtype">void</span> convertKeyPoints(<a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a>&amp; d_keypoints, std::vector&lt;KeyPoint&gt;&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01711"></a>01711 
<a name="l01713"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#a852bdf3aaa1e42a87ed7bf08b3d7e3b1">01713</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#a852bdf3aaa1e42a87ed7bf08b3d7e3b1" title="returns the descriptor size in bytes">descriptorSize</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> kBytes; }
<a name="l01714"></a>01714 
<a name="l01715"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#a34ee3127b5622c799955154159c96aac">01715</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> setFastParams(<span class="keywordtype">int</span> <a class="code" href="namespacecv_1_1gpu.html#a63944c7054df081596be6b4cf94df871" title="applies fixed threshold to the image">threshold</a>, <span class="keywordtype">bool</span> nonmaxSupression = <span class="keyword">true</span>)
<a name="l01716"></a>01716     {
<a name="l01717"></a>01717         fastDetector_.threshold = <a class="code" href="namespacecv_1_1gpu.html#a63944c7054df081596be6b4cf94df871" title="applies fixed threshold to the image">threshold</a>;
<a name="l01718"></a>01718         fastDetector_.nonmaxSupression = nonmaxSupression;
<a name="l01719"></a>01719     }
<a name="l01720"></a>01720 
<a name="l01722"></a>01722     <span class="keywordtype">void</span> release();
<a name="l01723"></a>01723 
<a name="l01725"></a><a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#a58a0701ecca568ba949cd6e0e06ebaa6">01725</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_o_r_b___g_p_u.html#a58a0701ecca568ba949cd6e0e06ebaa6" title="if true, image will be blurred before descriptors calculation">blurForDescriptor</a>;
<a name="l01726"></a>01726 
<a name="l01727"></a>01727 <span class="keyword">private</span>:
<a name="l01728"></a>01728     <span class="keyword">enum</span> { kBytes = 32 };
<a name="l01729"></a>01729 
<a name="l01730"></a>01730     <span class="keywordtype">void</span> buildScalePyramids(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask);
<a name="l01731"></a>01731 
<a name="l01732"></a>01732     <span class="keywordtype">void</span> computeKeyPointsPyramid();
<a name="l01733"></a>01733 
<a name="l01734"></a>01734     <span class="keywordtype">void</span> computeDescriptors(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#a1e3702ddbca6258f57508c22eff26bf2">descriptors</a>);
<a name="l01735"></a>01735 
<a name="l01736"></a>01736     <span class="keywordtype">void</span> mergeKeyPoints(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="compat_8hpp.html#af95b6678bbbdd664ed15fe6d4190d355">keypoints</a>);
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     <span class="keywordtype">int</span> nFeatures_;
<a name="l01739"></a>01739     <span class="keywordtype">float</span> scaleFactor_;
<a name="l01740"></a>01740     <span class="keywordtype">int</span> nLevels_;
<a name="l01741"></a>01741     <span class="keywordtype">int</span> edgeThreshold_;
<a name="l01742"></a>01742     <span class="keywordtype">int</span> firstLevel_;
<a name="l01743"></a>01743     <span class="keywordtype">int</span> WTA_K_;
<a name="l01744"></a>01744     <span class="keywordtype">int</span> scoreType_;
<a name="l01745"></a>01745     <span class="keywordtype">int</span> patchSize_;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="comment">// The number of desired features per scale</span>
<a name="l01748"></a>01748     std::vector&lt;size_t&gt; n_features_per_level_;
<a name="l01749"></a>01749 
<a name="l01750"></a>01750     <span class="comment">// Points to compute BRIEF descriptors from</span>
<a name="l01751"></a>01751     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> pattern_;
<a name="l01752"></a>01752 
<a name="l01753"></a>01753     std::vector&lt;GpuMat&gt; imagePyr_;
<a name="l01754"></a>01754     std::vector&lt;GpuMat&gt; maskPyr_;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> buf_;
<a name="l01757"></a>01757 
<a name="l01758"></a>01758     std::vector&lt;GpuMat&gt; keyPointsPyr_;
<a name="l01759"></a>01759     std::vector&lt;int&gt; keyPointsCount_;
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     <a class="code" href="classcv_1_1gpu_1_1_f_a_s_t___g_p_u.html">FAST_GPU</a> fastDetector_;
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> blurFilter;
<a name="l01764"></a>01764 
<a name="l01765"></a>01765     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> d_keypoints_;
<a name="l01766"></a>01766 };
<a name="l01767"></a>01767 
<a name="l01769"></a>01769 
<a name="l01770"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html">01770</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html">BroxOpticalFlow</a>
<a name="l01771"></a>01771 {
<a name="l01772"></a>01772 <span class="keyword">public</span>:
<a name="l01773"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a21c7bb316c354657ed6272c791c2754f">01773</a>     <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html">BroxOpticalFlow</a>(<span class="keywordtype">float</span> alpha_, <span class="keywordtype">float</span> gamma_, <span class="keywordtype">float</span> scale_factor_, <span class="keywordtype">int</span> inner_iterations_, <span class="keywordtype">int</span> outer_iterations_, <span class="keywordtype">int</span> solver_iterations_) :
<a name="l01774"></a>01774         alpha(alpha_), gamma(gamma_), scale_factor(scale_factor_),
<a name="l01775"></a>01775         inner_iterations(inner_iterations_), outer_iterations(outer_iterations_), solver_iterations(solver_iterations_)
<a name="l01776"></a>01776     {
<a name="l01777"></a>01777     }
<a name="l01778"></a>01778 
<a name="l01784"></a>01784     <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; frame0, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; frame1, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; u, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; v, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01785"></a>01785 
<a name="l01787"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a3cde47ad49aa16be21b776479d76e2a9">01787</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a3cde47ad49aa16be21b776479d76e2a9" title="flow smoothness">alpha</a>;
<a name="l01788"></a>01788 
<a name="l01790"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a38340441419110e891bbe148be6ca6ab">01790</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a38340441419110e891bbe148be6ca6ab" title="gradient constancy importance">gamma</a>;
<a name="l01791"></a>01791 
<a name="l01793"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#add237683953a02e7da3757aa555b7a9f">01793</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#add237683953a02e7da3757aa555b7a9f" title="pyramid scale factor">scale_factor</a>;
<a name="l01794"></a>01794 
<a name="l01796"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#ae6cd22cc2991f12a092a5887d769b5d7">01796</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#ae6cd22cc2991f12a092a5887d769b5d7" title="number of lagged non-linearity iterations (inner loop)">inner_iterations</a>;
<a name="l01797"></a>01797 
<a name="l01799"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a93127c77d03b809ec869f3651162efc0">01799</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a93127c77d03b809ec869f3651162efc0" title="number of warping iterations (number of pyramid levels)">outer_iterations</a>;
<a name="l01800"></a>01800 
<a name="l01802"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a2d987464ab9a0919409047db591b64ad">01802</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a2d987464ab9a0919409047db591b64ad" title="number of linear system solver iterations">solver_iterations</a>;
<a name="l01803"></a>01803 
<a name="l01804"></a><a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a8966537234dabe1808b1b66d1dc8ab04">01804</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> <a class="code" href="classcv_1_1gpu_1_1_brox_optical_flow.html#a8966537234dabe1808b1b66d1dc8ab04">buf</a>;
<a name="l01805"></a>01805 };
<a name="l01806"></a>01806 
<a name="l01807"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html">01807</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html">GoodFeaturesToTrackDetector_GPU</a>
<a name="l01808"></a>01808 {
<a name="l01809"></a>01809 <span class="keyword">public</span>:
<a name="l01810"></a>01810     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html">GoodFeaturesToTrackDetector_GPU</a>(<span class="keywordtype">int</span> maxCorners = 1000, <span class="keywordtype">double</span> qualityLevel = 0.01, <span class="keywordtype">double</span> minDistance = 0.0,
<a name="l01811"></a>01811         <span class="keywordtype">int</span> blockSize = 3, <span class="keywordtype">bool</span> useHarrisDetector = <span class="keyword">false</span>, <span class="keywordtype">double</span> harrisK = 0.04);
<a name="l01812"></a>01812 
<a name="l01814"></a>01814     <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="calib3d_8hpp.html#a7c963d5c0be2901e72c3762c1ddfcee6">corners</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; mask = <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>());
<a name="l01815"></a>01815 
<a name="l01816"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#ac1e628216d9e0cef86e53f3804660ea3">01816</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#ac1e628216d9e0cef86e53f3804660ea3">maxCorners</a>;
<a name="l01817"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a9f5f8a99c745336967c83605ab01adf4">01817</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a9f5f8a99c745336967c83605ab01adf4">qualityLevel</a>;
<a name="l01818"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#af0ea46c4aec5a06aece948dba21b17c3">01818</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#af0ea46c4aec5a06aece948dba21b17c3">minDistance</a>;
<a name="l01819"></a>01819 
<a name="l01820"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a06b3fe45e1f30303c8f50fd9d9d0fe04">01820</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a06b3fe45e1f30303c8f50fd9d9d0fe04">blockSize</a>;
<a name="l01821"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a5ae93a396eeb8eb0978026d57b14acea">01821</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a5ae93a396eeb8eb0978026d57b14acea">useHarrisDetector</a>;
<a name="l01822"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a17f5ed8317c8f07eac81568971b07bc9">01822</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a17f5ed8317c8f07eac81568971b07bc9">harrisK</a>;
<a name="l01823"></a>01823 
<a name="l01824"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a202411eb7d3aad5b9233321921b0aada">01824</a>     <span class="keywordtype">void</span> releaseMemory()
<a name="l01825"></a>01825     {
<a name="l01826"></a>01826         Dx_.release();
<a name="l01827"></a>01827         Dy_.release();
<a name="l01828"></a>01828         buf_.release();
<a name="l01829"></a>01829         eig_.release();
<a name="l01830"></a>01830         minMaxbuf_.release();
<a name="l01831"></a>01831         tmpCorners_.release();
<a name="l01832"></a>01832     }
<a name="l01833"></a>01833 
<a name="l01834"></a>01834 <span class="keyword">private</span>:
<a name="l01835"></a>01835     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> Dx_;
<a name="l01836"></a>01836     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> Dy_;
<a name="l01837"></a>01837     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> buf_;
<a name="l01838"></a>01838     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> eig_;
<a name="l01839"></a>01839     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> minMaxbuf_;
<a name="l01840"></a>01840     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> tmpCorners_;
<a name="l01841"></a>01841 };
<a name="l01842"></a>01842 
<a name="l01843"></a><a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a592765f1969b419cbd15e7c6f852dad6">01843</a> <span class="keyword">inline</span> <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a592765f1969b419cbd15e7c6f852dad6">GoodFeaturesToTrackDetector_GPU::GoodFeaturesToTrackDetector_GPU</a>(<span class="keywordtype">int</span> maxCorners_, <span class="keywordtype">double</span> qualityLevel_, <span class="keywordtype">double</span> minDistance_,
<a name="l01844"></a>01844         <span class="keywordtype">int</span> blockSize_, <span class="keywordtype">bool</span> useHarrisDetector_, <span class="keywordtype">double</span> harrisK_)
<a name="l01845"></a>01845 {
<a name="l01846"></a>01846     <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#ac1e628216d9e0cef86e53f3804660ea3">maxCorners</a> = maxCorners_;
<a name="l01847"></a>01847     <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a9f5f8a99c745336967c83605ab01adf4">qualityLevel</a> = qualityLevel_;
<a name="l01848"></a>01848     <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#af0ea46c4aec5a06aece948dba21b17c3">minDistance</a> = minDistance_;
<a name="l01849"></a>01849     blockSize = blockSize_;
<a name="l01850"></a>01850     <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a5ae93a396eeb8eb0978026d57b14acea">useHarrisDetector</a> = useHarrisDetector_;
<a name="l01851"></a>01851     <a class="code" href="classcv_1_1gpu_1_1_good_features_to_track_detector___g_p_u.html#a17f5ed8317c8f07eac81568971b07bc9">harrisK</a> = harrisK_;
<a name="l01852"></a>01852 }
<a name="l01853"></a>01853 
<a name="l01854"></a>01854 
<a name="l01855"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html">01855</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html">PyrLKOpticalFlow</a>
<a name="l01856"></a>01856 {
<a name="l01857"></a>01857 <span class="keyword">public</span>:
<a name="l01858"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#afe312e0710a2c1da0cdc8f1bd0242811">01858</a>     <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html">PyrLKOpticalFlow</a>()
<a name="l01859"></a>01859     {
<a name="l01860"></a>01860         winSize = <a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(21, 21);
<a name="l01861"></a>01861         maxLevel = 3;
<a name="l01862"></a>01862         iters = 30;
<a name="l01863"></a>01863         derivLambda = 0.5;
<a name="l01864"></a>01864         useInitialFlow = <span class="keyword">false</span>;
<a name="l01865"></a>01865         minEigThreshold = 1e-4f;
<a name="l01866"></a>01866         getMinEigenVals = <span class="keyword">false</span>;
<a name="l01867"></a>01867         isDeviceArch11_ = !<a class="code" href="classcv_1_1gpu_1_1_device_info.html">DeviceInfo</a>().<a class="code" href="classcv_1_1gpu_1_1_device_info.html#ab28ac66ad12c85e01702389ca773d84f">supports</a>(<a class="code" href="namespacecv_1_1gpu.html#a80e2488654340f05ddad1edb660e2c30affb1c9bd20d9a8ff7bcb2f7ecf3cb953">FEATURE_SET_COMPUTE_12</a>);
<a name="l01868"></a>01868     }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870     <span class="keywordtype">void</span> sparse(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; prevImg, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nextImg, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; prevPts, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nextPts,
<a name="l01871"></a>01871         <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="tracking_8hpp.html#ae17b3c2584dab511e91d1c96644018bf">status</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>* err = 0);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     <span class="keywordtype">void</span> dense(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; prevImg, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; nextImg, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; u, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; v, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>* err = 0);
<a name="l01874"></a>01874 
<a name="l01875"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a30efdd5ddcd7f9add4d1e54e1cae4d13">01875</a>     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a30efdd5ddcd7f9add4d1e54e1cae4d13">winSize</a>;
<a name="l01876"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a9547259cedcde31896d4048facb2e42c">01876</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a9547259cedcde31896d4048facb2e42c">maxLevel</a>;
<a name="l01877"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a2eacc032fafd4e2c0a88812f595ac3fd">01877</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a2eacc032fafd4e2c0a88812f595ac3fd">iters</a>;
<a name="l01878"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a1bab1d7e3675aead1a2a06d02e1bf7d0">01878</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a1bab1d7e3675aead1a2a06d02e1bf7d0">derivLambda</a>;
<a name="l01879"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#abf0839aead118df3ad71dbf43e4c0d81">01879</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#abf0839aead118df3ad71dbf43e4c0d81">useInitialFlow</a>;
<a name="l01880"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#acb8639f4ef29e9c6e5a4d242e97e6e52">01880</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#acb8639f4ef29e9c6e5a4d242e97e6e52">minEigThreshold</a>;
<a name="l01881"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a605dc8a54385d4058a2fc49929c41ec4">01881</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a605dc8a54385d4058a2fc49929c41ec4">getMinEigenVals</a>;
<a name="l01882"></a>01882 
<a name="l01883"></a><a class="code" href="classcv_1_1gpu_1_1_pyr_l_k_optical_flow.html#a43e7b0856d228e95fc981caed310a266">01883</a>     <span class="keywordtype">void</span> releaseMemory()
<a name="l01884"></a>01884     {
<a name="l01885"></a>01885         dx_calcBuf_.release();
<a name="l01886"></a>01886         dy_calcBuf_.release();
<a name="l01887"></a>01887 
<a name="l01888"></a>01888         prevPyr_.clear();
<a name="l01889"></a>01889         nextPyr_.clear();
<a name="l01890"></a>01890 
<a name="l01891"></a>01891         dx_buf_.release();
<a name="l01892"></a>01892         dy_buf_.release();
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         uPyr_.clear();
<a name="l01895"></a>01895         vPyr_.clear();
<a name="l01896"></a>01896     }
<a name="l01897"></a>01897 
<a name="l01898"></a>01898 <span class="keyword">private</span>:
<a name="l01899"></a>01899     <span class="keywordtype">void</span> calcSharrDeriv(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; src, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; dy);
<a name="l01900"></a>01900 
<a name="l01901"></a>01901     <span class="keywordtype">void</span> buildImagePyramid(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; img0, vector&lt;GpuMat&gt;&amp; pyr, <span class="keywordtype">bool</span> withBorder);
<a name="l01902"></a>01902 
<a name="l01903"></a>01903     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> dx_calcBuf_;
<a name="l01904"></a>01904     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> dy_calcBuf_;
<a name="l01905"></a>01905 
<a name="l01906"></a>01906     vector&lt;GpuMat&gt; prevPyr_;
<a name="l01907"></a>01907     vector&lt;GpuMat&gt; nextPyr_;
<a name="l01908"></a>01908 
<a name="l01909"></a>01909     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> dx_buf_;
<a name="l01910"></a>01910     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> dy_buf_;
<a name="l01911"></a>01911 
<a name="l01912"></a>01912     vector&lt;GpuMat&gt; uPyr_;
<a name="l01913"></a>01913     vector&lt;GpuMat&gt; vPyr_;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915     <span class="keywordtype">bool</span> isDeviceArch11_;
<a name="l01916"></a>01916 };
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 
<a name="l01919"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html">01919</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html">FarnebackOpticalFlow</a>
<a name="l01920"></a>01920 {
<a name="l01921"></a>01921 <span class="keyword">public</span>:
<a name="l01922"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#aa1d5d3ff167c512d21c139dd349f6208">01922</a>     <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html">FarnebackOpticalFlow</a>()
<a name="l01923"></a>01923     {
<a name="l01924"></a>01924         numLevels = 5;
<a name="l01925"></a>01925         pyrScale = 0.5;
<a name="l01926"></a>01926         fastPyramids = <span class="keyword">false</span>;
<a name="l01927"></a>01927         winSize = 13;
<a name="l01928"></a>01928         numIters = 10;
<a name="l01929"></a>01929         polyN = 5;
<a name="l01930"></a>01930         polySigma = 1.1;
<a name="l01931"></a>01931         flags = 0;
<a name="l01932"></a>01932         isDeviceArch11_ = !<a class="code" href="classcv_1_1gpu_1_1_device_info.html">DeviceInfo</a>().<a class="code" href="classcv_1_1gpu_1_1_device_info.html#ab28ac66ad12c85e01702389ca773d84f">supports</a>(<a class="code" href="namespacecv_1_1gpu.html#a80e2488654340f05ddad1edb660e2c30affb1c9bd20d9a8ff7bcb2f7ecf3cb953">FEATURE_SET_COMPUTE_12</a>);
<a name="l01933"></a>01933     }
<a name="l01934"></a>01934 
<a name="l01935"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a65e8ba26c07a9e492d39cab4b2a50ee8">01935</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a65e8ba26c07a9e492d39cab4b2a50ee8">numLevels</a>;
<a name="l01936"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#afd28cb6ab5a507fe87f264e5e26ec2ea">01936</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#afd28cb6ab5a507fe87f264e5e26ec2ea">pyrScale</a>;
<a name="l01937"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a65eba919aaaa05ef2af657b480a44f65">01937</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a65eba919aaaa05ef2af657b480a44f65">fastPyramids</a>;
<a name="l01938"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a1d732b231fbb0ebdbb6533bd5f959c64">01938</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a1d732b231fbb0ebdbb6533bd5f959c64">winSize</a>;
<a name="l01939"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a7626bd1a1fbe35004056512aa5e178b7">01939</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a7626bd1a1fbe35004056512aa5e178b7">numIters</a>;
<a name="l01940"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a95230f24301b3f53f318cb9052e068fd">01940</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a95230f24301b3f53f318cb9052e068fd">polyN</a>;
<a name="l01941"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#ae64754d971eec5984f3d8f43f60997a2">01941</a>     <span class="keywordtype">double</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#ae64754d971eec5984f3d8f43f60997a2">polySigma</a>;
<a name="l01942"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a65c45101360cdf9a161104d1ad165584">01942</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a65c45101360cdf9a161104d1ad165584">flags</a>;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944     <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;frame0, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;frame1, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;flowx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;flowy, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a> &amp;s = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l01945"></a>01945 
<a name="l01946"></a><a class="code" href="classcv_1_1gpu_1_1_farneback_optical_flow.html#a7c3008d5a6e948b6a59b68888b3277bf">01946</a>     <span class="keywordtype">void</span> releaseMemory()
<a name="l01947"></a>01947     {
<a name="l01948"></a>01948         frames_[0].release();
<a name="l01949"></a>01949         frames_[1].release();
<a name="l01950"></a>01950         pyrLevel_[0].release();
<a name="l01951"></a>01951         pyrLevel_[1].release();
<a name="l01952"></a>01952         M_.release();
<a name="l01953"></a>01953         bufM_.release();
<a name="l01954"></a>01954         R_[0].release();
<a name="l01955"></a>01955         R_[1].release();
<a name="l01956"></a>01956         blurredFrame_[0].release();
<a name="l01957"></a>01957         blurredFrame_[1].release();
<a name="l01958"></a>01958         pyramid0_.clear();
<a name="l01959"></a>01959         pyramid1_.clear();
<a name="l01960"></a>01960     }
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 <span class="keyword">private</span>:
<a name="l01963"></a>01963     <span class="keywordtype">void</span> prepareGaussian(
<a name="l01964"></a>01964             <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> sigma, <span class="keywordtype">float</span> *g, <span class="keywordtype">float</span> *xg, <span class="keywordtype">float</span> *xxg,
<a name="l01965"></a>01965             <span class="keywordtype">double</span> &amp;ig11, <span class="keywordtype">double</span> &amp;ig03, <span class="keywordtype">double</span> &amp;ig33, <span class="keywordtype">double</span> &amp;ig55);
<a name="l01966"></a>01966 
<a name="l01967"></a>01967     <span class="keywordtype">void</span> setPolynomialExpansionConsts(<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> sigma);
<a name="l01968"></a>01968 
<a name="l01969"></a>01969     <span class="keywordtype">void</span> updateFlow_boxFilter(
<a name="l01970"></a>01970             <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; R0, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="calib3d_8hpp.html#ab4d5cbb79188a091449ea6430cd5ec59">R1</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; flowx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;flowy,
<a name="l01971"></a>01971             <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; M, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;bufM, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">bool</span> updateMatrices, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a> streams[]);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973     <span class="keywordtype">void</span> updateFlow_gaussianBlur(
<a name="l01974"></a>01974             <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; R0, <span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="calib3d_8hpp.html#ab4d5cbb79188a091449ea6430cd5ec59">R1</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; flowx, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; flowy,
<a name="l01975"></a>01975             <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; M, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> &amp;bufM, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">bool</span> updateMatrices, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a> streams[]);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> frames_[2];
<a name="l01978"></a>01978     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> pyrLevel_[2], M_, bufM_, R_[2], blurredFrame_[2];
<a name="l01979"></a>01979     std::vector&lt;GpuMat&gt; pyramid0_, pyramid1_;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     <span class="keywordtype">bool</span> isDeviceArch11_;
<a name="l01982"></a>01982 };
<a name="l01983"></a>01983 
<a name="l01984"></a>01984 
<a name="l01999"></a>01999 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#aaf2bd7135aecc1c566c9bcdb5be5e1f2">interpolateFrames</a>(<span class="keyword">const</span> GpuMat&amp; frame0, <span class="keyword">const</span> GpuMat&amp; frame1,
<a name="l02000"></a>02000                                   <span class="keyword">const</span> GpuMat&amp; fu, <span class="keyword">const</span> GpuMat&amp; fv,
<a name="l02001"></a>02001                                   <span class="keyword">const</span> GpuMat&amp; bu, <span class="keyword">const</span> GpuMat&amp; bv,
<a name="l02002"></a>02002                                   <span class="keywordtype">float</span> <a class="code" href="core__c_8h.html#a6492959798ef439146ab2816fe754d81">pos</a>, GpuMat&amp; newFrame, GpuMat&amp; buf,
<a name="l02003"></a>02003                                   Stream&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l02004"></a>02004 
<a name="l02005"></a>02005 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#afbca1952f714fe4cd1a9b7a99c71dd8e">createOpticalFlowNeedleMap</a>(<span class="keyword">const</span> GpuMat&amp; u, <span class="keyword">const</span> GpuMat&amp; v, GpuMat&amp; <a class="code" href="legacy_8hpp.html#ac8a106041f9639c956b255212cfe857e">vertex</a>, GpuMat&amp; colors);
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 
<a name="l02009"></a>02009 
<a name="l02010"></a>02010 <span class="comment">// Foreground Object Detection from Videos Containing Complex Background.</span>
<a name="l02011"></a>02011 <span class="comment">// Liyuan Li, Weimin Huang, Irene Y.H. Gu, and Qi Tian.</span>
<a name="l02012"></a>02012 <span class="comment">// ACM MM2003 9p</span>
<a name="l02013"></a><a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">02013</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>
<a name="l02014"></a>02014 {
<a name="l02015"></a>02015 <span class="keyword">public</span>:
<a name="l02016"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">02016</a>     <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">Params</a>
<a name="l02017"></a>02017     {
<a name="l02018"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a859698b36c00550ec238f317d9660286">02018</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a859698b36c00550ec238f317d9660286">Lc</a>;  <span class="comment">// Quantized levels per &#39;color&#39; component. Power of two, typically 32, 64 or 128.</span>
<a name="l02019"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a957ca619e785188c7b390c8b5faefdc4">02019</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a957ca619e785188c7b390c8b5faefdc4">N1c</a>; <span class="comment">// Number of color vectors used to model normal background color variation at a given pixel.</span>
<a name="l02020"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a33685186c1bfb25d854a1e1e14fc2ad3">02020</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a33685186c1bfb25d854a1e1e14fc2ad3">N2c</a>; <span class="comment">// Number of color vectors retained at given pixel.  Must be &gt; N1c, typically ~ 5/3 of N1c.</span>
<a name="l02021"></a>02021         <span class="comment">// Used to allow the first N1c vectors to adapt over time to changing background.</span>
<a name="l02022"></a>02022 
<a name="l02023"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#afab9c00a68b21ed3c4dafebd23c60547">02023</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#afab9c00a68b21ed3c4dafebd23c60547">Lcc</a>;  <span class="comment">// Quantized levels per &#39;color co-occurrence&#39; component.  Power of two, typically 16, 32 or 64.</span>
<a name="l02024"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#ac20ee9490221abb9268f7b713942ed44">02024</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#ac20ee9490221abb9268f7b713942ed44">N1cc</a>; <span class="comment">// Number of color co-occurrence vectors used to model normal background color variation at a given pixel.</span>
<a name="l02025"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a4312dc7d29e659c844c7fee0162fa070">02025</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a4312dc7d29e659c844c7fee0162fa070">N2cc</a>; <span class="comment">// Number of color co-occurrence vectors retained at given pixel.  Must be &gt; N1cc, typically ~ 5/3 of N1cc.</span>
<a name="l02026"></a>02026         <span class="comment">// Used to allow the first N1cc vectors to adapt over time to changing background.</span>
<a name="l02027"></a>02027 
<a name="l02028"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#adadf53794d6aa8a151f68ff0b6840fba">02028</a>         <span class="keywordtype">bool</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#adadf53794d6aa8a151f68ff0b6840fba">is_obj_without_holes</a>; <span class="comment">// If TRUE we ignore holes within foreground blobs. Defaults to TRUE.</span>
<a name="l02029"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a0f0a1c9ddd3b66d1b3a4aa10826dd0a7">02029</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a0f0a1c9ddd3b66d1b3a4aa10826dd0a7">perform_morphing</a>;     <span class="comment">// Number of erode-dilate-erode foreground-blob cleanup iterations.</span>
<a name="l02030"></a>02030         <span class="comment">// These erase one-pixel junk blobs and merge almost-touching blobs. Default value is 1.</span>
<a name="l02031"></a>02031 
<a name="l02032"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a088911ceee79da8523bb8d489df8fe3c">02032</a>         <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a088911ceee79da8523bb8d489df8fe3c">alpha1</a>; <span class="comment">// How quickly we forget old background pixel values seen. Typically set to 0.1.</span>
<a name="l02033"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a90895cf2429972c84546aad28462dcc9">02033</a>         <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a90895cf2429972c84546aad28462dcc9">alpha2</a>; <span class="comment">// &quot;Controls speed of feature learning&quot;. Depends on T. Typical value circa 0.005.</span>
<a name="l02034"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a2a2b8887693ccff22e63725f36ed84a2">02034</a>         <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a2a2b8887693ccff22e63725f36ed84a2">alpha3</a>; <span class="comment">// Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.</span>
<a name="l02035"></a>02035 
<a name="l02036"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a6427682d26a608b924e96928139b3d17">02036</a>         <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a6427682d26a608b924e96928139b3d17">delta</a>;   <span class="comment">// Affects color and color co-occurrence quantization, typically set to 2.</span>
<a name="l02037"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a16c905f2d50f44f6ccf5c62efc1bfb64">02037</a>         <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#a16c905f2d50f44f6ccf5c62efc1bfb64">T</a>;       <span class="comment">// A percentage value which determines when new features can be recognized as new background. (Typically 0.9).</span>
<a name="l02038"></a><a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#aa640a266a42d7ad172c3abf6518cb8f7">02038</a>         <span class="keywordtype">float</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html#aa640a266a42d7ad172c3abf6518cb8f7">minArea</a>; <span class="comment">// Discard foreground blobs whose bounding box is smaller than this threshold.</span>
<a name="l02039"></a>02039 
<a name="l02040"></a>02040         <span class="comment">// default Params</span>
<a name="l02041"></a>02041         <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">Params</a>();
<a name="l02042"></a>02042     };
<a name="l02043"></a>02043 
<a name="l02044"></a>02044     <span class="comment">// out_cn - channels count in output result (can be 3 or 4)</span>
<a name="l02045"></a>02045     <span class="comment">// 4-channels require more memory, but a bit faster</span>
<a name="l02046"></a>02046     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>(<span class="keywordtype">int</span> out_cn = 3);
<a name="l02047"></a>02047     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">cv::gpu::GpuMat</a>&amp; firstFrame, <span class="keyword">const</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">Params</a>&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a> = <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">Params</a>(), <span class="keywordtype">int</span> out_cn = 3);
<a name="l02048"></a>02048 
<a name="l02049"></a>02049     ~<a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>();
<a name="l02050"></a>02050 
<a name="l02051"></a>02051     <span class="keywordtype">void</span> create(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">cv::gpu::GpuMat</a>&amp; firstFrame, <span class="keyword">const</span> <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">Params</a>&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a> = <a class="code" href="structcv_1_1gpu_1_1_f_g_d_stat_model_1_1_params.html">Params</a>());
<a name="l02052"></a>02052     <span class="keywordtype">void</span> release();
<a name="l02053"></a>02053 
<a name="l02054"></a>02054     <span class="keywordtype">int</span> update(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">cv::gpu::GpuMat</a>&amp; curFrame);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056     <span class="comment">//8UC3 or 8UC4 reference background image</span>
<a name="l02057"></a><a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html#a5338d077962abc68f3bdf86dbfdf7fb5">02057</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">cv::gpu::GpuMat</a> <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html#a5338d077962abc68f3bdf86dbfdf7fb5">background</a>;
<a name="l02058"></a>02058 
<a name="l02059"></a>02059     <span class="comment">//8UC1 foreground image</span>
<a name="l02060"></a><a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html#a45433418635a48e18f1faefca63b2d19">02060</a>     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">cv::gpu::GpuMat</a> <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html#a45433418635a48e18f1faefca63b2d19">foreground</a>;
<a name="l02061"></a>02061 
<a name="l02062"></a><a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html#a8ebaaacff6c039db9c53d60640102243">02062</a>     std::vector&lt; std::vector&lt;cv::Point&gt; &gt; <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html#a8ebaaacff6c039db9c53d60640102243">foreground_regions</a>;
<a name="l02063"></a>02063 
<a name="l02064"></a>02064 <span class="keyword">private</span>:
<a name="l02065"></a>02065     <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>&amp;);
<a name="l02066"></a>02066     <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_f_g_d_stat_model.html">FGDStatModel</a>&amp;);
<a name="l02067"></a>02067 
<a name="l02068"></a>02068     <span class="keyword">class </span>Impl;
<a name="l02069"></a>02069     std::auto_ptr&lt;Impl&gt; impl_;
<a name="l02070"></a>02070 };
<a name="l02071"></a>02071 
<a name="l02081"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html">02081</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html" title="Gaussian Mixture-based Backbround/Foreground Segmentation Algorithm.">MOG_GPU</a>
<a name="l02082"></a>02082 {
<a name="l02083"></a>02083 <span class="keyword">public</span>:
<a name="l02085"></a>02085     <a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html" title="Gaussian Mixture-based Backbround/Foreground Segmentation Algorithm.">MOG_GPU</a>(<span class="keywordtype">int</span> nmixtures = -1);
<a name="l02086"></a>02086 
<a name="l02088"></a>02088     <span class="keywordtype">void</span> initialize(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize, <span class="keywordtype">int</span> frameType);
<a name="l02089"></a>02089 
<a name="l02091"></a>02091     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a0430deaafd9043e478f306e33961299d">frame</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="legacy_8hpp.html#a7ff9edf5eaa300d3c1cea7de20631fd8">fgmask</a>, <span class="keywordtype">float</span> learningRate = 0.0f, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l02092"></a>02092 
<a name="l02094"></a>02094     <span class="keywordtype">void</span> getBackgroundImage(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; backgroundImage, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) <span class="keyword">const</span>;
<a name="l02095"></a>02095 
<a name="l02097"></a>02097     <span class="keywordtype">void</span> release();
<a name="l02098"></a>02098 
<a name="l02099"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#a73ca55f7883c8411201ff0230d9aa6fb">02099</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#a73ca55f7883c8411201ff0230d9aa6fb">history</a>;
<a name="l02100"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#a65fd382117fb5965c920875dd3426ae6">02100</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#a65fd382117fb5965c920875dd3426ae6">varThreshold</a>;
<a name="l02101"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#ab19166eef3431fed0abb108a3718db19">02101</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#ab19166eef3431fed0abb108a3718db19">backgroundRatio</a>;
<a name="l02102"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#a9b7ae4e418ff449890e290bd44f0d858">02102</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g___g_p_u.html#a9b7ae4e418ff449890e290bd44f0d858">noiseSigma</a>;
<a name="l02103"></a>02103 
<a name="l02104"></a>02104 <span class="keyword">private</span>:
<a name="l02105"></a>02105     <span class="keywordtype">int</span> nmixtures_;
<a name="l02106"></a>02106 
<a name="l02107"></a>02107     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize_;
<a name="l02108"></a>02108     <span class="keywordtype">int</span> frameType_;
<a name="l02109"></a>02109     <span class="keywordtype">int</span> nframes_;
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> weight_;
<a name="l02112"></a>02112     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> sortKey_;
<a name="l02113"></a>02113     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> mean_;
<a name="l02114"></a>02114     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> var_;
<a name="l02115"></a>02115 };
<a name="l02116"></a>02116 
<a name="l02124"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html">02124</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html" title="The class implements the following algorithm: &quot;Improved adaptive Gausian mixture model for background...">MOG2_GPU</a>
<a name="l02125"></a>02125 {
<a name="l02126"></a>02126 <span class="keyword">public</span>:
<a name="l02128"></a>02128     <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html" title="The class implements the following algorithm: &quot;Improved adaptive Gausian mixture model for background...">MOG2_GPU</a>(<span class="keywordtype">int</span> nmixtures = -1);
<a name="l02129"></a>02129 
<a name="l02131"></a>02131     <span class="keywordtype">void</span> initialize(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize, <span class="keywordtype">int</span> frameType);
<a name="l02132"></a>02132 
<a name="l02134"></a>02134     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a0430deaafd9043e478f306e33961299d">frame</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="legacy_8hpp.html#a7ff9edf5eaa300d3c1cea7de20631fd8">fgmask</a>, <span class="keywordtype">float</span> learningRate = -1.0f, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l02135"></a>02135 
<a name="l02137"></a>02137     <span class="keywordtype">void</span> getBackgroundImage(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; backgroundImage, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>()) <span class="keyword">const</span>;
<a name="l02138"></a>02138 
<a name="l02140"></a>02140     <span class="keywordtype">void</span> release();
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     <span class="comment">// parameters</span>
<a name="l02143"></a>02143     <span class="comment">// you should call initialize after parameters changes</span>
<a name="l02144"></a>02144 
<a name="l02145"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a403f85c4f33fb111943daba58b0b21f0">02145</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a403f85c4f33fb111943daba58b0b21f0">history</a>;
<a name="l02146"></a>02146 
<a name="l02149"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a19f742a3fa03f0d43e73a288b8cab65c">02149</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a19f742a3fa03f0d43e73a288b8cab65c" title="here it is the maximum allowed number of mixture components. Actual number is determined dynamically ...">varThreshold</a>;
<a name="l02150"></a>02150     <span class="comment">// threshold on the squared Mahalanobis distance to decide if it is well described</span>
<a name="l02151"></a>02151     <span class="comment">// by the background model or not. Related to Cthr from the paper.</span>
<a name="l02152"></a>02152     <span class="comment">// This does not influence the update of the background. A typical value could be 4 sigma</span>
<a name="l02153"></a>02153     <span class="comment">// and that is varThreshold=4*4=16; Corresponds to Tb in the paper.</span>
<a name="l02154"></a>02154 
<a name="l02156"></a>02156     <span class="comment">// less important parameters - things you might change but be carefull</span>
<a name="l02158"></a>02158 <span class="comment"></span>
<a name="l02159"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#ab646673e679c021d6971eeba1b44abfa">02159</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#ab646673e679c021d6971eeba1b44abfa">backgroundRatio</a>;
<a name="l02160"></a>02160     <span class="comment">// corresponds to fTB=1-cf from the paper</span>
<a name="l02161"></a>02161     <span class="comment">// TB - threshold when the component becomes significant enough to be included into</span>
<a name="l02162"></a>02162     <span class="comment">// the background model. It is the TB=1-cf from the paper. So I use cf=0.1 =&gt; TB=0.</span>
<a name="l02163"></a>02163     <span class="comment">// For alpha=0.001 it means that the mode should exist for approximately 105 frames before</span>
<a name="l02164"></a>02164     <span class="comment">// it is considered foreground</span>
<a name="l02165"></a>02165     <span class="comment">// float noiseSigma;</span>
<a name="l02166"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a90ab8efe3e16585ecb93656d321fbebc">02166</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a90ab8efe3e16585ecb93656d321fbebc">varThresholdGen</a>;
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     <span class="comment">//correspondts to Tg - threshold on the squared Mahalan. dist. to decide</span>
<a name="l02169"></a>02169     <span class="comment">//when a sample is close to the existing components. If it is not close</span>
<a name="l02170"></a>02170     <span class="comment">//to any a new component will be generated. I use 3 sigma =&gt; Tg=3*3=9.</span>
<a name="l02171"></a>02171     <span class="comment">//Smaller Tg leads to more generated components and higher Tg might make</span>
<a name="l02172"></a>02172     <span class="comment">//lead to small number of components but they can grow too large</span>
<a name="l02173"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#af6c5ff19e5ca4c4e80bdb330a40a9b0f">02173</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#af6c5ff19e5ca4c4e80bdb330a40a9b0f">fVarInit</a>;
<a name="l02174"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a898eb021a33aeb3ba8883dd1e734dce0">02174</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a898eb021a33aeb3ba8883dd1e734dce0">fVarMin</a>;
<a name="l02175"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#ad45804934365ec0dd8dc49f90b6ebce2">02175</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#ad45804934365ec0dd8dc49f90b6ebce2">fVarMax</a>;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177     <span class="comment">//initial variance  for the newly generated components.</span>
<a name="l02178"></a>02178     <span class="comment">//It will will influence the speed of adaptation. A good guess should be made.</span>
<a name="l02179"></a>02179     <span class="comment">//A simple way is to estimate the typical standard deviation from the images.</span>
<a name="l02180"></a>02180     <span class="comment">//I used here 10 as a reasonable value</span>
<a name="l02181"></a>02181     <span class="comment">// min and max can be used to further control the variance</span>
<a name="l02182"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a2dd28f1330681ced7f872e0ae8b3f0ef">02182</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a2dd28f1330681ced7f872e0ae8b3f0ef">fCT</a>; <span class="comment">//CT - complexity reduction prior</span>
<a name="l02183"></a>02183     <span class="comment">//this is related to the number of samples needed to accept that a component</span>
<a name="l02184"></a>02184     <span class="comment">//actually exists. We use CT=0.05 of all the samples. By setting CT=0 you get</span>
<a name="l02185"></a>02185     <span class="comment">//the standard Stauffer&amp;Grimson algorithm (maybe not exact but very similar)</span>
<a name="l02186"></a>02186 
<a name="l02187"></a>02187     <span class="comment">//shadow detection parameters</span>
<a name="l02188"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#ae7b0f3d5c29a710e4185ec1fb9335b96">02188</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#ae7b0f3d5c29a710e4185ec1fb9335b96">bShadowDetection</a>; <span class="comment">//default 1 - do shadow detection</span>
<a name="l02189"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#aa78756f4db93b7c599a5830d3fc9592e">02189</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#aa78756f4db93b7c599a5830d3fc9592e">nShadowDetection</a>; <span class="comment">//do shadow detection - insert this value as the detection result - 127 default value</span>
<a name="l02190"></a><a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a0a1a2553c82bd821783e4840e4c9c6ee">02190</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_m_o_g2___g_p_u.html#a0a1a2553c82bd821783e4840e4c9c6ee">fTau</a>;
<a name="l02191"></a>02191     <span class="comment">// Tau - shadow threshold. The shadow is detected if the pixel is darker</span>
<a name="l02192"></a>02192     <span class="comment">//version of the background. Tau is a threshold on how much darker the shadow can be.</span>
<a name="l02193"></a>02193     <span class="comment">//Tau= 0.5 means that if pixel is more than 2 times darker then it is not shadow</span>
<a name="l02194"></a>02194     <span class="comment">//See: Prati,Mikic,Trivedi,Cucchiarra,&quot;Detecting Moving Shadows...&quot;,IEEE PAMI,2003.</span>
<a name="l02195"></a>02195 
<a name="l02196"></a>02196 <span class="keyword">private</span>:
<a name="l02197"></a>02197     <span class="keywordtype">int</span> nmixtures_;
<a name="l02198"></a>02198 
<a name="l02199"></a>02199     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize_;
<a name="l02200"></a>02200     <span class="keywordtype">int</span> frameType_;
<a name="l02201"></a>02201     <span class="keywordtype">int</span> nframes_;
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> weight_;
<a name="l02204"></a>02204     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> variance_;
<a name="l02205"></a>02205     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> mean_;
<a name="l02206"></a>02206 
<a name="l02207"></a>02207     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> bgmodelUsedModes_; <span class="comment">//keep track of number of modes per pixel</span>
<a name="l02208"></a>02208 };
<a name="l02209"></a>02209 
<a name="l02216"></a><a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html">02216</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html" title="The class implements the following algorithm: &quot;ViBe: A universal background subtraction algorithm for...">VIBE_GPU</a>
<a name="l02217"></a>02217 {
<a name="l02218"></a>02218 <span class="keyword">public</span>:
<a name="l02220"></a>02220     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html" title="The class implements the following algorithm: &quot;ViBe: A universal background subtraction algorithm for...">VIBE_GPU</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rngSeed = 1234567);
<a name="l02221"></a>02221 
<a name="l02223"></a>02223     <span class="keywordtype">void</span> initialize(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; firstFrame, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l02224"></a>02224 
<a name="l02226"></a>02226     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a0430deaafd9043e478f306e33961299d">frame</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="legacy_8hpp.html#a7ff9edf5eaa300d3c1cea7de20631fd8">fgmask</a>, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l02227"></a>02227 
<a name="l02229"></a>02229     <span class="keywordtype">void</span> release();
<a name="l02230"></a>02230 
<a name="l02231"></a><a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#a25044d488cd6f842cde27eb12cf122c6">02231</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#a25044d488cd6f842cde27eb12cf122c6">nbSamples</a>;         <span class="comment">// number of samples per pixel</span>
<a name="l02232"></a><a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#a7914e88cbaabcbcb16f297e5ce6ffbcb">02232</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#a7914e88cbaabcbcb16f297e5ce6ffbcb">reqMatches</a>;        <span class="comment">// #_min</span>
<a name="l02233"></a><a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#ae956f31e7dd260fe71261686e4f246c3">02233</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#ae956f31e7dd260fe71261686e4f246c3">radius</a>;            <span class="comment">// R</span>
<a name="l02234"></a><a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#a8f3ef108771cff731846bfbc5058cb2f">02234</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_v_i_b_e___g_p_u.html#a8f3ef108771cff731846bfbc5058cb2f">subsamplingFactor</a>; <span class="comment">// amount of random subsampling</span>
<a name="l02235"></a>02235 
<a name="l02236"></a>02236 <span class="keyword">private</span>:
<a name="l02237"></a>02237     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize_;
<a name="l02238"></a>02238 
<a name="l02239"></a>02239     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rngSeed_;
<a name="l02240"></a>02240     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> randStates_;
<a name="l02241"></a>02241 
<a name="l02242"></a>02242     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> samples_;
<a name="l02243"></a>02243 };
<a name="l02244"></a>02244 
<a name="l02252"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html">02252</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html">GMG_GPU</a>
<a name="l02253"></a>02253 {
<a name="l02254"></a>02254 <span class="keyword">public</span>:
<a name="l02255"></a>02255     <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html">GMG_GPU</a>();
<a name="l02256"></a>02256 
<a name="l02263"></a>02263     <span class="keywordtype">void</span> initialize(<a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize, <span class="keywordtype">float</span> <a class="code" href="namespacecv_1_1gpu.html#a8d100341ab11a730a3c90b75d5890a8c" title="computes per-element minimum of two arrays (dst = min(src1, src2))">min</a> = 0.0f, <span class="keywordtype">float</span> <a class="code" href="namespacecv_1_1gpu.html#a706c9def6816de566be2671b75ec5309" title="computes per-element maximum of two arrays (dst = max(src1, src2))">max</a> = 255.0f);
<a name="l02264"></a>02264 
<a name="l02272"></a>02272     <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="core__c_8h.html#a0430deaafd9043e478f306e33961299d">frame</a>, <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; <a class="code" href="legacy_8hpp.html#a7ff9edf5eaa300d3c1cea7de20631fd8">fgmask</a>, <span class="keywordtype">float</span> learningRate = -1.0f, <a class="code" href="classcv_1_1gpu_1_1_stream.html">Stream</a>&amp; stream = <a class="code" href="classcv_1_1gpu_1_1_stream.html#af96c23564834f88333dcb8997df553f1">Stream::Null</a>());
<a name="l02273"></a>02273 
<a name="l02275"></a>02275     <span class="keywordtype">void</span> release();
<a name="l02276"></a>02276 
<a name="l02278"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#aef13a3000e96aea8f8599e933e0b0492">02278</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#aef13a3000e96aea8f8599e933e0b0492" title="Total number of distinct colors to maintain in histogram.">maxFeatures</a>;
<a name="l02279"></a>02279 
<a name="l02281"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a05dad91a91ad2a893a79f0b95920e24c">02281</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a05dad91a91ad2a893a79f0b95920e24c" title="Set between 0.0 and 1.0, determines how quickly features are &quot;forgotten&quot; from histograms.">learningRate</a>;
<a name="l02282"></a>02282 
<a name="l02284"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#ab4796b2f60da0a859dd242ec5681ea43">02284</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#ab4796b2f60da0a859dd242ec5681ea43" title="Number of frames of video to use to initialize histograms.">numInitializationFrames</a>;
<a name="l02285"></a>02285 
<a name="l02287"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a562b4ad84c3c15f6c952e26304a854f1">02287</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a562b4ad84c3c15f6c952e26304a854f1" title="Number of discrete levels in each channel to be used in histograms.">quantizationLevels</a>;
<a name="l02288"></a>02288 
<a name="l02290"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a6377c73b49c025ba5ff12cbe6cf9f96d">02290</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a6377c73b49c025ba5ff12cbe6cf9f96d" title="Prior probability that any given pixel is a background pixel. A sensitivity parameter.">backgroundPrior</a>;
<a name="l02291"></a>02291 
<a name="l02293"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a5ce273fb8c841b45377fa0111f71c8cc">02293</a>     <span class="keywordtype">float</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a5ce273fb8c841b45377fa0111f71c8cc" title="Value above which pixel is determined to be FG.">decisionThreshold</a>;
<a name="l02294"></a>02294 
<a name="l02296"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a5e2cb2fbb20a7a83ac0ae19c0ba3a8a8">02296</a>     <span class="keywordtype">int</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a5e2cb2fbb20a7a83ac0ae19c0ba3a8a8" title="Smoothing radius, in pixels, for cleaning up FG image.">smoothingRadius</a>;
<a name="l02297"></a>02297 
<a name="l02299"></a><a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a2c756a5e5ec6c2160d6a440642d0909f">02299</a>     <span class="keywordtype">bool</span> <a class="code" href="classcv_1_1gpu_1_1_g_m_g___g_p_u.html#a2c756a5e5ec6c2160d6a440642d0909f" title="Perform background model update.">updateBackgroundModel</a>;
<a name="l02300"></a>02300 
<a name="l02301"></a>02301 <span class="keyword">private</span>:
<a name="l02302"></a>02302     <span class="keywordtype">float</span> maxVal_, minVal_;
<a name="l02303"></a>02303 
<a name="l02304"></a>02304     <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> frameSize_;
<a name="l02305"></a>02305 
<a name="l02306"></a>02306     <span class="keywordtype">int</span> frameNum_;
<a name="l02307"></a>02307 
<a name="l02308"></a>02308     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> nfeatures_;
<a name="l02309"></a>02309     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> colors_;
<a name="l02310"></a>02310     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> weights_;
<a name="l02311"></a>02311 
<a name="l02312"></a>02312     <a class="code" href="classcv_1_1_ptr.html">Ptr&lt;FilterEngine_GPU&gt;</a> boxFilter_;
<a name="l02313"></a>02313     <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a> buf_;
<a name="l02314"></a>02314 };
<a name="l02315"></a>02315 
<a name="l02317"></a>02317 
<a name="l02318"></a>02318 <span class="comment">// Works only under Windows</span>
<a name="l02319"></a>02319 <span class="comment">// Supports olny H264 video codec and AVI files</span>
<a name="l02320"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">02320</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>
<a name="l02321"></a>02321 {
<a name="l02322"></a>02322 <span class="keyword">public</span>:
<a name="l02323"></a>02323     <span class="keyword">struct </span><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html">EncoderParams</a>;
<a name="l02324"></a>02324 
<a name="l02325"></a>02325     <span class="comment">// Callbacks for video encoder, use it if you want to work with raw video stream</span>
<a name="l02326"></a>02326     <span class="keyword">class </span><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html">EncoderCallBack</a>;
<a name="l02327"></a>02327 
<a name="l02328"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8db">02328</a>     <span class="keyword">enum</span> <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8db">SurfaceFormat</a>
<a name="l02329"></a>02329     {
<a name="l02330"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dbae329e5e79a7d8abd3edc80d394e19f2c">02330</a>         SF_UYVY = 0,
<a name="l02331"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba0d795cdf8b11cf5df489d540bbe56d2a">02331</a>         <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba0d795cdf8b11cf5df489d540bbe56d2a">SF_YUY2</a>,
<a name="l02332"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba31c8f5c7259645357e4bca68a423ed96">02332</a>         <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba31c8f5c7259645357e4bca68a423ed96">SF_YV12</a>,
<a name="l02333"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba688d7ba26f43460820414360f1b053b6">02333</a>         <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba688d7ba26f43460820414360f1b053b6">SF_NV12</a>,
<a name="l02334"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba933d1c20c20c3292cb6c29b25385c58d">02334</a>         <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba933d1c20c20c3292cb6c29b25385c58d">SF_IYUV</a>,
<a name="l02335"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba7177ece8afd220ce60266029e5b12da8">02335</a>         <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba7177ece8afd220ce60266029e5b12da8">SF_BGR</a>,
<a name="l02336"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html#ada559c518c52735d64366823e897e8dba32c4f628079f6b5c7eb97bd36395ff3b">02336</a>         SF_GRAY = SF_BGR
<a name="l02337"></a>02337     };
<a name="l02338"></a>02338 
<a name="l02339"></a>02339     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>();
<a name="l02340"></a>02340     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; fileName, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02341"></a>02341     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; fileName, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, <span class="keyword">const</span> EncoderParams&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02342"></a>02342     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">cv::Ptr&lt;EncoderCallBack&gt;</a>&amp; encoderCallback, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02343"></a>02343     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">cv::Ptr&lt;EncoderCallBack&gt;</a>&amp; encoderCallback, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, <span class="keyword">const</span> EncoderParams&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02344"></a>02344     ~<a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>();
<a name="l02345"></a>02345 
<a name="l02346"></a>02346     <span class="comment">// all methods throws cv::Exception if error occurs</span>
<a name="l02347"></a>02347     <span class="keywordtype">void</span> open(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; fileName, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02348"></a>02348     <span class="keywordtype">void</span> open(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; fileName, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, <span class="keyword">const</span> EncoderParams&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02349"></a>02349     <span class="keywordtype">void</span> open(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">cv::Ptr&lt;EncoderCallBack&gt;</a>&amp; encoderCallback, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02350"></a>02350     <span class="keywordtype">void</span> open(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">cv::Ptr&lt;EncoderCallBack&gt;</a>&amp; encoderCallback, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">cv::Size</a> frameSize, <span class="keywordtype">double</span> <a class="code" href="highgui__c_8h.html#adbca5b692e9ace76ccf02d9c621ee228">fps</a>, <span class="keyword">const</span> EncoderParams&amp; <a class="code" href="compat_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>, SurfaceFormat <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a> = SF_BGR);
<a name="l02351"></a>02351 
<a name="l02352"></a>02352     <span class="keywordtype">bool</span> isOpened() <span class="keyword">const</span>;
<a name="l02353"></a>02353     <span class="keywordtype">void</span> <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/_app_cocoa_touch_8mm.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();
<a name="l02354"></a>02354 
<a name="l02355"></a>02355     <span class="keywordtype">void</span> <a class="code" href="namespacecv.html#a61de8505ed5c9f5698861dec08e35a7d">write</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">cv::gpu::GpuMat</a>&amp; image, <span class="keywordtype">bool</span> lastFrame = <span class="keyword">false</span>);
<a name="l02356"></a>02356 
<a name="l02357"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html">02357</a>     <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html">EncoderParams</a>
<a name="l02358"></a>02358     {
<a name="l02359"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#af6b2b5aaffb429643ac6fdb3a97995c9">02359</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#af6b2b5aaffb429643ac6fdb3a97995c9">P_Interval</a>;      <span class="comment">//    NVVE_P_INTERVAL,</span>
<a name="l02360"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a3f54de95350cd16c19eca4d94c67220b">02360</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a3f54de95350cd16c19eca4d94c67220b">IDR_Period</a>;      <span class="comment">//    NVVE_IDR_PERIOD,</span>
<a name="l02361"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#aae0defd9124971f130a87e290e1192a6">02361</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#aae0defd9124971f130a87e290e1192a6">DynamicGOP</a>;      <span class="comment">//    NVVE_DYNAMIC_GOP,</span>
<a name="l02362"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#acf99e6f1c0a59c82c0dfdb7e7d09240f">02362</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#acf99e6f1c0a59c82c0dfdb7e7d09240f">RCType</a>;          <span class="comment">//    NVVE_RC_TYPE,</span>
<a name="l02363"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a5657bdc4de3af96ee035224dd51b2393">02363</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a5657bdc4de3af96ee035224dd51b2393">AvgBitrate</a>;      <span class="comment">//    NVVE_AVG_BITRATE,</span>
<a name="l02364"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a572b0afd18117efae3803ae2d8a503cd">02364</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a572b0afd18117efae3803ae2d8a503cd">PeakBitrate</a>;     <span class="comment">//    NVVE_PEAK_BITRATE,</span>
<a name="l02365"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#aa2c27da41d1d6d971946ee3febfef652">02365</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#aa2c27da41d1d6d971946ee3febfef652">QP_Level_Intra</a>;  <span class="comment">//    NVVE_QP_LEVEL_INTRA,</span>
<a name="l02366"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a8ca625f276ae370de7acbd3e49976743">02366</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a8ca625f276ae370de7acbd3e49976743">QP_Level_InterP</a>; <span class="comment">//    NVVE_QP_LEVEL_INTER_P,</span>
<a name="l02367"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a1414850923c34e0e0325944400c68cf6">02367</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a1414850923c34e0e0325944400c68cf6">QP_Level_InterB</a>; <span class="comment">//    NVVE_QP_LEVEL_INTER_B,</span>
<a name="l02368"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a712c6a083474dbb952938a79b60494da">02368</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a712c6a083474dbb952938a79b60494da">DeblockMode</a>;     <span class="comment">//    NVVE_DEBLOCK_MODE,</span>
<a name="l02369"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#ac93bcbbd6eb30a44da3f8a47e30dbb14">02369</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#ac93bcbbd6eb30a44da3f8a47e30dbb14">ProfileLevel</a>;    <span class="comment">//    NVVE_PROFILE_LEVEL,</span>
<a name="l02370"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a309ba8d5e846e37b7d4c81fa33c2d8e8">02370</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a309ba8d5e846e37b7d4c81fa33c2d8e8">ForceIntra</a>;      <span class="comment">//    NVVE_FORCE_INTRA,</span>
<a name="l02371"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#ab2b29f99a5b143efafaaf743e29a4726">02371</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#ab2b29f99a5b143efafaaf743e29a4726">ForceIDR</a>;        <span class="comment">//    NVVE_FORCE_IDR,</span>
<a name="l02372"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a4ef869f90a92ed5a0b8d2006be7ab8a5">02372</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a4ef869f90a92ed5a0b8d2006be7ab8a5">ClearStat</a>;       <span class="comment">//    NVVE_CLEAR_STAT,</span>
<a name="l02373"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a1357785fd66cf9bbeb59f53c9f26d272">02373</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a1357785fd66cf9bbeb59f53c9f26d272">DIMode</a>;          <span class="comment">//    NVVE_SET_DEINTERLACE,</span>
<a name="l02374"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#ae06f33b98e491272074a44dafd794191">02374</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#ae06f33b98e491272074a44dafd794191">Presets</a>;         <span class="comment">//    NVVE_PRESETS,</span>
<a name="l02375"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a18d86a510a2cbfc3ce1d3472d25f95ea">02375</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a18d86a510a2cbfc3ce1d3472d25f95ea">DisableCabac</a>;    <span class="comment">//    NVVE_DISABLE_CABAC,</span>
<a name="l02376"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a981c1acdb0268ffba66b07a69aff7ee5">02376</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a981c1acdb0268ffba66b07a69aff7ee5">NaluFramingType</a>; <span class="comment">//    NVVE_CONFIGURE_NALU_FRAMING_TYPE</span>
<a name="l02377"></a><a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a17662d6c7d0b1f3589def107beca90e5">02377</a>         <span class="keywordtype">int</span>       <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html#a17662d6c7d0b1f3589def107beca90e5">DisableSPSPPS</a>;   <span class="comment">//    NVVE_DISABLE_SPS_PPS</span>
<a name="l02378"></a>02378 
<a name="l02379"></a>02379         <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html">EncoderParams</a>();
<a name="l02380"></a>02380         <span class="keyword">explicit</span> <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html">EncoderParams</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; configFile);
<a name="l02381"></a>02381 
<a name="l02382"></a>02382         <span class="keywordtype">void</span> <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/namespacecinder_1_1audio.html#a71a6f579c46fcbee416f53d492659913">load</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; configFile);
<a name="l02383"></a>02383         <span class="keywordtype">void</span> save(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; configFile) <span class="keyword">const</span>;
<a name="l02384"></a>02384     };
<a name="l02385"></a>02385 
<a name="l02386"></a>02386     <a class="code" href="structcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_params.html">EncoderParams</a> getParams() <span class="keyword">const</span>;
<a name="l02387"></a>02387 
<a name="l02388"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html">02388</a>     <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html">EncoderCallBack</a>
<a name="l02389"></a>02389     {
<a name="l02390"></a>02390     <span class="keyword">public</span>:
<a name="l02391"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#aa8c69464d7b00114cd7b058a2738be0e">02391</a>         <span class="keyword">enum</span> <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#aa8c69464d7b00114cd7b058a2738be0e">PicType</a>
<a name="l02392"></a>02392         {
<a name="l02393"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#aa8c69464d7b00114cd7b058a2738be0ead0da42fdb1d4fdeef7363a0b07b1994a">02393</a>             IFRAME = 1,
<a name="l02394"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#aa8c69464d7b00114cd7b058a2738be0ea8067620fa9d0cc29606b84f8e0df8987">02394</a>             PFRAME = 2,
<a name="l02395"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#aa8c69464d7b00114cd7b058a2738be0eab2f9cfe19797bcbc8c147100a8c147fd">02395</a>             BFRAME = 3
<a name="l02396"></a>02396         };
<a name="l02397"></a>02397 
<a name="l02398"></a><a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#a97bcc1078b3fd45fe71cacaf1b0fb84c">02398</a>         <span class="keyword">virtual</span> <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u_1_1_encoder_call_back.html#a97bcc1078b3fd45fe71cacaf1b0fb84c">~EncoderCallBack</a>() {}
<a name="l02399"></a>02399 
<a name="l02400"></a>02400         <span class="comment">// callback function to signal the start of bitstream that is to be encoded</span>
<a name="l02401"></a>02401         <span class="comment">// must return pointer to buffer</span>
<a name="l02402"></a>02402         <span class="keyword">virtual</span> <a class="code" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* acquireBitStream(<span class="keywordtype">int</span>* bufferSize) = 0;
<a name="l02403"></a>02403 
<a name="l02404"></a>02404         <span class="comment">// callback function to signal that the encoded bitstream is ready to be written to file</span>
<a name="l02405"></a>02405         <span class="keyword">virtual</span> <span class="keywordtype">void</span> releaseBitStream(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <a class="code" href="core__c_8h.html#acd1647952fba31484ea63d6f1140e509">data</a>, <span class="keywordtype">int</span> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>) = 0;
<a name="l02406"></a>02406 
<a name="l02407"></a>02407         <span class="comment">// callback function to signal that the encoding operation on the frame has started</span>
<a name="l02408"></a>02408         <span class="keyword">virtual</span> <span class="keywordtype">void</span> onBeginFrame(<span class="keywordtype">int</span> frameNumber, PicType picType) = 0;
<a name="l02409"></a>02409 
<a name="l02410"></a>02410         <span class="comment">// callback function signals that the encoding operation on the frame has finished</span>
<a name="l02411"></a>02411         <span class="keyword">virtual</span> <span class="keywordtype">void</span> onEndFrame(<span class="keywordtype">int</span> frameNumber, PicType picType) = 0;
<a name="l02412"></a>02412     };
<a name="l02413"></a>02413 
<a name="l02414"></a>02414 <span class="keyword">private</span>:
<a name="l02415"></a>02415     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>&amp;);
<a name="l02416"></a>02416     <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_video_writer___g_p_u.html">VideoWriter_GPU</a>&amp;);
<a name="l02417"></a>02417 
<a name="l02418"></a>02418     <span class="keyword">class </span>Impl;
<a name="l02419"></a>02419     std::auto_ptr&lt;Impl&gt; impl_;
<a name="l02420"></a>02420 };
<a name="l02421"></a>02421 
<a name="l02422"></a>02422 
<a name="l02424"></a>02424 
<a name="l02425"></a><a class="code" href="namespacecv_1_1gpu_1_1detail.html">02425</a> <span class="keyword">namespace </span>detail
<a name="l02426"></a>02426 {
<a name="l02427"></a>02427     <span class="keyword">class </span>FrameQueue;
<a name="l02428"></a>02428     <span class="keyword">class </span>VideoParser;
<a name="l02429"></a>02429 }
<a name="l02430"></a>02430 
<a name="l02431"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">02431</a> <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>
<a name="l02432"></a>02432 {
<a name="l02433"></a>02433 <span class="keyword">public</span>:
<a name="l02434"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16">02434</a>     <span class="keyword">enum</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16">Codec</a>
<a name="l02435"></a>02435     {
<a name="l02436"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16ae45d3a13e8afae6ca1be2960f8013e64">02436</a>         MPEG1 = 0,
<a name="l02437"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a1682f11e5b0a752c50e794b2898eded5">02437</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a1682f11e5b0a752c50e794b2898eded5">MPEG2</a>,
<a name="l02438"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a86efa48f165eaa2a5d355911df0c65d4">02438</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a86efa48f165eaa2a5d355911df0c65d4">MPEG4</a>,
<a name="l02439"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16ac6a5613a9566438358dcdbaff21f44b1">02439</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16ac6a5613a9566438358dcdbaff21f44b1">VC1</a>,
<a name="l02440"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a9435375ca08f28730896b5fe484db50c">02440</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a9435375ca08f28730896b5fe484db50c">H264</a>,
<a name="l02441"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16af08c74922bd060445140efececc34b68">02441</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16af08c74922bd060445140efececc34b68">JPEG</a>,
<a name="l02442"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a8022fa6e413a138d538cbcb9b02cbaad">02442</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a8022fa6e413a138d538cbcb9b02cbaad">H264_SVC</a>,
<a name="l02443"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a87bfe22939cd0ee94a0add33f531fc02">02443</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a87bfe22939cd0ee94a0add33f531fc02">H264_MVC</a>,
<a name="l02444"></a>02444 
<a name="l02445"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a3ab8bb50e245637d7de0059e70c27f00">02445</a>         Uncompressed_YUV420 = ((<span class="charliteral">&#39;I&#39;</span>&lt;&lt;24)|(<span class="charliteral">&#39;Y&#39;</span>&lt;&lt;16)|(<span class="charliteral">&#39;U&#39;</span>&lt;&lt;8)|(<span class="charliteral">&#39;V&#39;</span>)),   <span class="comment">// Y,U,V (4:2:0)</span>
<a name="l02446"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16afa77a91bab757393306992fd2da789d6">02446</a>         Uncompressed_YV12   = ((<span class="charliteral">&#39;Y&#39;</span>&lt;&lt;24)|(<span class="charliteral">&#39;V&#39;</span>&lt;&lt;16)|(<span class="charliteral">&#39;1&#39;</span>&lt;&lt;8)|(<span class="charliteral">&#39;2&#39;</span>)),   <span class="comment">// Y,V,U (4:2:0)</span>
<a name="l02447"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16af1011079d17b28b695adb4733dbce0d9">02447</a>         Uncompressed_NV12   = ((<span class="charliteral">&#39;N&#39;</span>&lt;&lt;24)|(<span class="charliteral">&#39;V&#39;</span>&lt;&lt;16)|(<span class="charliteral">&#39;1&#39;</span>&lt;&lt;8)|(<span class="charliteral">&#39;2&#39;</span>)),   <span class="comment">// Y,UV  (4:2:0)</span>
<a name="l02448"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16af5bec2fec5c7b3b140d2da8c3a9423e7">02448</a>         Uncompressed_YUYV   = ((<span class="charliteral">&#39;Y&#39;</span>&lt;&lt;24)|(<span class="charliteral">&#39;U&#39;</span>&lt;&lt;16)|(<span class="charliteral">&#39;Y&#39;</span>&lt;&lt;8)|(<span class="charliteral">&#39;V&#39;</span>)),   <span class="comment">// YUYV/YUY2 (4:2:2)</span>
<a name="l02449"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16a7ed7a50e96ad35bb9cc104e8d460b4d7">02449</a>         Uncompressed_UYVY   = ((<span class="charliteral">&#39;U&#39;</span>&lt;&lt;24)|(<span class="charliteral">&#39;Y&#39;</span>&lt;&lt;16)|(<span class="charliteral">&#39;V&#39;</span>&lt;&lt;8)|(<span class="charliteral">&#39;Y&#39;</span>)),   <span class="comment">// UYVY (4:2:2)</span>
<a name="l02450"></a>02450     };
<a name="l02451"></a>02451 
<a name="l02452"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440">02452</a>     <span class="keyword">enum</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440">ChromaFormat</a>
<a name="l02453"></a>02453     {
<a name="l02454"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440a30354dcfc16f690550d4e32269586d4c">02454</a>         Monochrome=0,
<a name="l02455"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440ad1f70221be9016063f04d6183d1910a3">02455</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440ad1f70221be9016063f04d6183d1910a3">YUV420</a>,
<a name="l02456"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440a30cf7a5de82ef63bf4dc002d0358e31f">02456</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440a30cf7a5de82ef63bf4dc002d0358e31f">YUV422</a>,
<a name="l02457"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440a9eeb367fe3c3602193200c588d973623">02457</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440a9eeb367fe3c3602193200c588d973623">YUV444</a>,
<a name="l02458"></a>02458     };
<a name="l02459"></a>02459 
<a name="l02460"></a><a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html">02460</a>     <span class="keyword">struct </span><a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html">FormatInfo</a>
<a name="l02461"></a>02461     {
<a name="l02462"></a><a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#aa5adba8a81873df9339c844822887ad3">02462</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#afdb33778111ce0c50a8de381ad562b16">Codec</a> <a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#aa5adba8a81873df9339c844822887ad3">codec</a>;
<a name="l02463"></a><a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#a9400bdc8903cc435acbf37036a06225e">02463</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html#a7fc7968ff0961cdaa050b3845799b440">ChromaFormat</a> <a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#a9400bdc8903cc435acbf37036a06225e">chromaFormat</a>;
<a name="l02464"></a><a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#adc76516e2ddf81180fe8eb29719223c1">02464</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#adc76516e2ddf81180fe8eb29719223c1">width</a>;
<a name="l02465"></a><a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#a3922e3c3cb30e9dcb465db81176364ef">02465</a>         <span class="keywordtype">int</span> <a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html#a3922e3c3cb30e9dcb465db81176364ef">height</a>;
<a name="l02466"></a>02466     };
<a name="l02467"></a>02467 
<a name="l02468"></a>02468     <span class="keyword">class </span><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">VideoSource</a>;
<a name="l02469"></a>02469 
<a name="l02470"></a>02470     <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>();
<a name="l02471"></a>02471     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; <a class="code" href="core__c_8h.html#acc427f35f3bd9f865d39012657cc42f8">filename</a>);
<a name="l02472"></a>02472     <span class="keyword">explicit</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">cv::Ptr&lt;VideoSource&gt;</a>&amp; source);
<a name="l02473"></a>02473 
<a name="l02474"></a>02474     ~<a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>();
<a name="l02475"></a>02475 
<a name="l02476"></a>02476     <span class="keywordtype">void</span> open(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>&amp; <a class="code" href="core__c_8h.html#acc427f35f3bd9f865d39012657cc42f8">filename</a>);
<a name="l02477"></a>02477     <span class="keywordtype">void</span> open(<span class="keyword">const</span> <a class="code" href="classcv_1_1_ptr.html" title="Smart pointer to dynamically allocated objects.">cv::Ptr&lt;VideoSource&gt;</a>&amp; source);
<a name="l02478"></a>02478     <span class="keywordtype">bool</span> isOpened() <span class="keyword">const</span>;
<a name="l02479"></a>02479 
<a name="l02480"></a>02480     <span class="keywordtype">void</span> <a class="codeRef" doxygen="cinder.tag:../../../../docs/html/" href="../../../../docs/html/_app_cocoa_touch_8mm.html#a5ae591df94fc66ccb85cbb6565368bca">close</a>();
<a name="l02481"></a>02481 
<a name="l02482"></a>02482     <span class="keywordtype">bool</span> <a class="code" href="namespacecv.html#a619e0aa3096e0c21dd68917bab5ec86f">read</a>(<a class="code" href="classcv_1_1gpu_1_1_gpu_mat.html" title="Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat...">GpuMat</a>&amp; image);
<a name="l02483"></a>02483 
<a name="l02484"></a>02484     <a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html">FormatInfo</a> <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a>() <span class="keyword">const</span>;
<a name="l02485"></a>02485     <span class="keywordtype">void</span> dumpFormat(std::ostream&amp; st);
<a name="l02486"></a>02486 
<a name="l02487"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">02487</a>     <span class="keyword">class </span>CV_EXPORTS <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">VideoSource</a>
<a name="l02488"></a>02488     {
<a name="l02489"></a>02489     <span class="keyword">public</span>:
<a name="l02490"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a51a5f17a2f3073d98f85f63b6df5c161">02490</a>         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a51a5f17a2f3073d98f85f63b6df5c161">VideoSource</a>() : frameQueue_(0), videoParser_(0) {}
<a name="l02491"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a09b5047e0cdc07ef132e1cdd3ae32612">02491</a>         <span class="keyword">virtual</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a09b5047e0cdc07ef132e1cdd3ae32612">~VideoSource</a>() {}
<a name="l02492"></a>02492 
<a name="l02493"></a>02493         <span class="keyword">virtual</span> <a class="code" href="structcv_1_1gpu_1_1_video_reader___g_p_u_1_1_format_info.html">FormatInfo</a> <a class="code" href="namespacecv.html#a18435c327cd6be06af529e4c75cb40ab">format</a>() <span class="keyword">const</span> = 0;
<a name="l02494"></a>02494         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="core__c_8h.html#a45314566a84a31f43e6435d1eb24d4ec">start</a>() = 0;
<a name="l02495"></a>02495         <span class="keyword">virtual</span> <span class="keywordtype">void</span> stop() = 0;
<a name="l02496"></a>02496         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isStarted() <span class="keyword">const</span> = 0;
<a name="l02497"></a>02497         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> hasError() <span class="keyword">const</span> = 0;
<a name="l02498"></a>02498 
<a name="l02499"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a685f8c0310e885841aee10cf019897ed">02499</a>         <span class="keywordtype">void</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a685f8c0310e885841aee10cf019897ed">setFrameQueue</a>(detail::FrameQueue* frameQueue) { frameQueue_ = frameQueue; }
<a name="l02500"></a><a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a1f1313d4699ba15e2740efd4b69e1eae">02500</a>         <span class="keywordtype">void</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html#a1f1313d4699ba15e2740efd4b69e1eae">setVideoParser</a>(detail::VideoParser* videoParser) { videoParser_ = videoParser; }
<a name="l02501"></a>02501 
<a name="l02502"></a>02502     <span class="keyword">protected</span>:
<a name="l02503"></a>02503         <span class="keywordtype">bool</span> parseVideoData(<span class="keyword">const</span> <a class="code" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="code" href="core__c_8h.html#acd1647952fba31484ea63d6f1140e509">data</a>, <span class="keywordtype">size_t</span> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>, <span class="keywordtype">bool</span> endOfStream = <span class="keyword">false</span>);
<a name="l02504"></a>02504 
<a name="l02505"></a>02505     <span class="keyword">private</span>:
<a name="l02506"></a>02506         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">VideoSource</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">VideoSource</a>&amp;);
<a name="l02507"></a>02507         <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">VideoSource</a>&amp; operator =(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u_1_1_video_source.html">VideoSource</a>&amp;);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509         detail::FrameQueue* frameQueue_;
<a name="l02510"></a>02510         detail::VideoParser* videoParser_;
<a name="l02511"></a>02511     };
<a name="l02512"></a>02512 
<a name="l02513"></a>02513 <span class="keyword">private</span>:
<a name="l02514"></a>02514     <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>&amp;);
<a name="l02515"></a>02515     <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>&amp; operator =(<span class="keyword">const</span> <a class="code" href="classcv_1_1gpu_1_1_video_reader___g_p_u.html">VideoReader_GPU</a>&amp;);
<a name="l02516"></a>02516 
<a name="l02517"></a>02517     <span class="keyword">class </span>Impl;
<a name="l02518"></a>02518     std::auto_ptr&lt;Impl&gt; impl_;
<a name="l02519"></a>02519 };
<a name="l02520"></a>02520 
<a name="l02522"></a>02522 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a8c44a7a4fdb16ee4ab5f88d508e39e3b" title="removes points (CV_32FC2, single row matrix) with zero mask value">compactPoints</a>(GpuMat &amp;points0, GpuMat &amp;<a class="code" href="calib3d_8hpp.html#a3b72d48e58a35993385885cbc187c91d">points1</a>, <span class="keyword">const</span> GpuMat &amp;mask);
<a name="l02523"></a>02523 
<a name="l02524"></a>02524 CV_EXPORTS <span class="keywordtype">void</span> <a class="code" href="namespacecv_1_1gpu.html#a42baee27c9d9bcc9a66b0854829f42f2">calcWobbleSuppressionMaps</a>(
<a name="l02525"></a>02525         <span class="keywordtype">int</span> left, <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, <span class="keywordtype">int</span> right, <a class="code" href="classcv_1_1_size__.html" title="The 2D size class.">Size</a> <a class="code" href="calib3d_8hpp.html#ae97003f8d5c64cdfb99f6f2606d121b6">size</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> &amp;ml, <span class="keyword">const</span> <a class="code" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">Mat</a> &amp;mr,
<a name="l02526"></a>02526         GpuMat &amp;<a class="code" href="imgproc__c_8h.html#a81ed33f30ee89704887ae4e4dbb20d46">mapx</a>, GpuMat &amp;<a class="code" href="imgproc__c_8h.html#a934abd37467ed645178fbe201add061e">mapy</a>);
<a name="l02527"></a>02527 
<a name="l02528"></a>02528 } <span class="comment">// namespace gpu</span>
<a name="l02529"></a>02529 
<a name="l02530"></a>02530 } <span class="comment">// namespace cv</span>
<a name="l02531"></a>02531 
<a name="l02532"></a>02532 <span class="preprocessor">#endif </span><span class="comment">/* __OPENCV_GPU_HPP__ */</span>
</pre></div></div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
